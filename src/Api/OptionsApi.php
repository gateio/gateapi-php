<?php
/**
 * OptionsApi
 * PHP version 7
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */

/**
 * Gate API
 *
 * Welcome to Gate API  APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 * Generated by: https://openapi-generator.tech
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace GateApi\Api;

use GateApi\ApiException;
use GateApi\Configuration;
use GateApi\GateApiException;
use GateApi\HeaderSelector;
use GateApi\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * OptionsApi Class Doc Comment
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */
class OptionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation listOptionsUnderlyings
     *
     * List all underlyings
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsUnderlying[]
     */
    public function listOptionsUnderlyings()
    {
        list($response) = $this->listOptionsUnderlyingsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listOptionsUnderlyingsWithHttpInfo
     *
     * List all underlyings
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsUnderlying[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsUnderlyingsWithHttpInfo()
    {
        $request = $this->listOptionsUnderlyingsRequest();

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsUnderlying[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsUnderlyingsAsync
     *
     * List all underlyings
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsUnderlyingsAsync()
    {
        return $this->listOptionsUnderlyingsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsUnderlyingsAsyncWithHttpInfo
     *
     * List all underlyings
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsUnderlyingsAsyncWithHttpInfo()
    {
        $returnType = '\GateApi\Model\OptionsUnderlying[]';
        $request = $this->listOptionsUnderlyingsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsUnderlyings'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsUnderlyingsRequest()
    {

        $resourcePath = '/options/underlyings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsExpirations
     *
     * List all expiration times
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int[]
     */
    public function listOptionsExpirations($underlying)
    {
        list($response) = $this->listOptionsExpirationsWithHttpInfo($underlying);
        return $response;
    }

    /**
     * Operation listOptionsExpirationsWithHttpInfo
     *
     * List all expiration times
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsExpirationsWithHttpInfo($underlying)
    {
        $request = $this->listOptionsExpirationsRequest($underlying);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = 'int[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsExpirationsAsync
     *
     * List all expiration times
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsExpirationsAsync($underlying)
    {
        return $this->listOptionsExpirationsAsyncWithHttpInfo($underlying)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsExpirationsAsyncWithHttpInfo
     *
     * List all expiration times
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsExpirationsAsyncWithHttpInfo($underlying)
    {
        $returnType = 'int[]';
        $request = $this->listOptionsExpirationsRequest($underlying);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsExpirations'
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsExpirationsRequest($underlying)
    {
        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsExpirations'
            );
        }

        $resourcePath = '/options/expirations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsContracts
     *
     * List all the contracts with specified underlying and expiration time
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $expiration Unix timestamp of the expiration time (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsContract[]
     */
    public function listOptionsContracts($associative_array)
    {
        list($response) = $this->listOptionsContractsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsContractsWithHttpInfo
     *
     * List all the contracts with specified underlying and expiration time
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $expiration Unix timestamp of the expiration time (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsContract[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsContractsWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsContractsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsContract[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsContractsAsync
     *
     * List all the contracts with specified underlying and expiration time
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $expiration Unix timestamp of the expiration time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsContractsAsync($associative_array)
    {
        return $this->listOptionsContractsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsContractsAsyncWithHttpInfo
     *
     * List all the contracts with specified underlying and expiration time
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $expiration Unix timestamp of the expiration time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsContractsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsContract[]';
        $request = $this->listOptionsContractsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsContracts'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $expiration Unix timestamp of the expiration time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsContractsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $expiration = array_key_exists('expiration', $associative_array) ? $associative_array['expiration'] : null;

        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsContracts'
            );
        }

        $resourcePath = '/options/contracts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($expiration !== null) {
            if('form' === 'form' && is_array($expiration)) {
                foreach($expiration as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['expiration'] = $expiration;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOptionsContract
     *
     * Query specified contract detail
     *
     * @param  string $contract contract (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsContract
     */
    public function getOptionsContract($contract)
    {
        list($response) = $this->getOptionsContractWithHttpInfo($contract);
        return $response;
    }

    /**
     * Operation getOptionsContractWithHttpInfo
     *
     * Query specified contract detail
     *
     * @param  string $contract (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsContract, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOptionsContractWithHttpInfo($contract)
    {
        $request = $this->getOptionsContractRequest($contract);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsContract';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getOptionsContractAsync
     *
     * Query specified contract detail
     *
     * @param  string $contract (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsContractAsync($contract)
    {
        return $this->getOptionsContractAsyncWithHttpInfo($contract)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOptionsContractAsyncWithHttpInfo
     *
     * Query specified contract detail
     *
     * @param  string $contract (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsContractAsyncWithHttpInfo($contract)
    {
        $returnType = '\GateApi\Model\OptionsContract';
        $request = $this->getOptionsContractRequest($contract);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOptionsContract'
     *
     * @param  string $contract (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOptionsContractRequest($contract)
    {
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling getOptionsContract'
            );
        }

        $resourcePath = '/options/contracts/{contract}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsSettlements
     *
     * List settlement history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsSettlement[]
     */
    public function listOptionsSettlements($associative_array)
    {
        list($response) = $this->listOptionsSettlementsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsSettlementsWithHttpInfo
     *
     * List settlement history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsSettlement[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsSettlementsWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsSettlementsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsSettlement[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsSettlementsAsync
     *
     * List settlement history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsSettlementsAsync($associative_array)
    {
        return $this->listOptionsSettlementsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsSettlementsAsyncWithHttpInfo
     *
     * List settlement history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsSettlementsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsSettlement[]';
        $request = $this->listOptionsSettlementsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsSettlements'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsSettlementsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsSettlements'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsSettlements, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsSettlements, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling OptionsApi.listOptionsSettlements, must be bigger than or equal to 0.');
        }


        $resourcePath = '/options/settlements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOptionsSettlement
     *
     * Get specified contract's settlement
     *
     * @param  string $contract contract (required)
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $at at (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsSettlement
     */
    public function getOptionsSettlement($contract, $underlying, $at)
    {
        list($response) = $this->getOptionsSettlementWithHttpInfo($contract, $underlying, $at);
        return $response;
    }

    /**
     * Operation getOptionsSettlementWithHttpInfo
     *
     * Get specified contract's settlement
     *
     * @param  string $contract (required)
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $at (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsSettlement, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOptionsSettlementWithHttpInfo($contract, $underlying, $at)
    {
        $request = $this->getOptionsSettlementRequest($contract, $underlying, $at);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsSettlement';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getOptionsSettlementAsync
     *
     * Get specified contract's settlement
     *
     * @param  string $contract (required)
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $at (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsSettlementAsync($contract, $underlying, $at)
    {
        return $this->getOptionsSettlementAsyncWithHttpInfo($contract, $underlying, $at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOptionsSettlementAsyncWithHttpInfo
     *
     * Get specified contract's settlement
     *
     * @param  string $contract (required)
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $at (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsSettlementAsyncWithHttpInfo($contract, $underlying, $at)
    {
        $returnType = '\GateApi\Model\OptionsSettlement';
        $request = $this->getOptionsSettlementRequest($contract, $underlying, $at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOptionsSettlement'
     *
     * @param  string $contract (required)
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $at (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOptionsSettlementRequest($contract, $underlying, $at)
    {
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling getOptionsSettlement'
            );
        }
        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling getOptionsSettlement'
            );
        }
        // verify the required parameter 'at' is set
        if ($at === null || (is_array($at) && count($at) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $at when calling getOptionsSettlement'
            );
        }

        $resourcePath = '/options/settlements/{contract}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMyOptionsSettlements
     *
     * List my options settlements
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsMySettlements[]
     */
    public function listMyOptionsSettlements($associative_array)
    {
        list($response) = $this->listMyOptionsSettlementsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listMyOptionsSettlementsWithHttpInfo
     *
     * List my options settlements
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsMySettlements[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listMyOptionsSettlementsWithHttpInfo($associative_array)
    {
        $request = $this->listMyOptionsSettlementsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsMySettlements[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listMyOptionsSettlementsAsync
     *
     * List my options settlements
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMyOptionsSettlementsAsync($associative_array)
    {
        return $this->listMyOptionsSettlementsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMyOptionsSettlementsAsyncWithHttpInfo
     *
     * List my options settlements
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMyOptionsSettlementsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsMySettlements[]';
        $request = $this->listMyOptionsSettlementsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMyOptionsSettlements'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMyOptionsSettlementsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listMyOptionsSettlements'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listMyOptionsSettlements, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listMyOptionsSettlements, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling OptionsApi.listMyOptionsSettlements, must be bigger than or equal to 0.');
        }


        $resourcePath = '/options/my_settlements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsOrderBook
     *
     * Options order book
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0 (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrderBook
     */
    public function listOptionsOrderBook($associative_array)
    {
        list($response) = $this->listOptionsOrderBookWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsOrderBookWithHttpInfo
     *
     * Options order book
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0 (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrderBook, HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsOrderBookWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsOrderBookRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrderBook';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsOrderBookAsync
     *
     * Options order book
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0 (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsOrderBookAsync($associative_array)
    {
        return $this->listOptionsOrderBookAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsOrderBookAsyncWithHttpInfo
     *
     * Options order book
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0 (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsOrderBookAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesOrderBook';
        $request = $this->listOptionsOrderBookRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsOrderBook'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0 (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsOrderBookRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '0';
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 10;
        $with_id = array_key_exists('with_id', $associative_array) ? $associative_array['with_id'] : false;

        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listOptionsOrderBook'
            );
        }
        if ($limit !== null && $limit > 50) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsOrderBook, must be smaller than or equal to 50.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsOrderBook, must be bigger than or equal to 1.');
        }


        $resourcePath = '/options/order_book';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($with_id !== null) {
            if('form' === 'form' && is_array($with_id)) {
                foreach($with_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['with_id'] = $with_id;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsTickers
     *
     * List tickers of options contracts
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsTicker[]
     */
    public function listOptionsTickers($underlying)
    {
        list($response) = $this->listOptionsTickersWithHttpInfo($underlying);
        return $response;
    }

    /**
     * Operation listOptionsTickersWithHttpInfo
     *
     * List tickers of options contracts
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsTicker[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsTickersWithHttpInfo($underlying)
    {
        $request = $this->listOptionsTickersRequest($underlying);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsTicker[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsTickersAsync
     *
     * List tickers of options contracts
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsTickersAsync($underlying)
    {
        return $this->listOptionsTickersAsyncWithHttpInfo($underlying)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsTickersAsyncWithHttpInfo
     *
     * List tickers of options contracts
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsTickersAsyncWithHttpInfo($underlying)
    {
        $returnType = '\GateApi\Model\OptionsTicker[]';
        $request = $this->listOptionsTickersRequest($underlying);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsTickers'
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsTickersRequest($underlying)
    {
        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsTickers'
            );
        }

        $resourcePath = '/options/tickers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsUnderlyingTickers
     *
     * Get underlying ticker
     *
     * @param  string $underlying Underlying (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsUnderlyingTicker
     */
    public function listOptionsUnderlyingTickers($underlying)
    {
        list($response) = $this->listOptionsUnderlyingTickersWithHttpInfo($underlying);
        return $response;
    }

    /**
     * Operation listOptionsUnderlyingTickersWithHttpInfo
     *
     * Get underlying ticker
     *
     * @param  string $underlying Underlying (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsUnderlyingTicker, HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsUnderlyingTickersWithHttpInfo($underlying)
    {
        $request = $this->listOptionsUnderlyingTickersRequest($underlying);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsUnderlyingTicker';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsUnderlyingTickersAsync
     *
     * Get underlying ticker
     *
     * @param  string $underlying Underlying (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsUnderlyingTickersAsync($underlying)
    {
        return $this->listOptionsUnderlyingTickersAsyncWithHttpInfo($underlying)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsUnderlyingTickersAsyncWithHttpInfo
     *
     * Get underlying ticker
     *
     * @param  string $underlying Underlying (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsUnderlyingTickersAsyncWithHttpInfo($underlying)
    {
        $returnType = '\GateApi\Model\OptionsUnderlyingTicker';
        $request = $this->listOptionsUnderlyingTickersRequest($underlying);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsUnderlyingTickers'
     *
     * @param  string $underlying Underlying (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsUnderlyingTickersRequest($underlying)
    {
        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsUnderlyingTickers'
            );
        }

        $resourcePath = '/options/underlying/tickers/{underlying}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($underlying !== null) {
            $resourcePath = str_replace(
                '{' . 'underlying' . '}',
                ObjectSerializer::toPathValue($underlying),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsCandlesticks
     *
     * Get options candlesticks
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsCandlestick[]
     */
    public function listOptionsCandlesticks($associative_array)
    {
        list($response) = $this->listOptionsCandlesticksWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsCandlesticksWithHttpInfo
     *
     * Get options candlesticks
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsCandlestick[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsCandlesticksWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsCandlesticksRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsCandlestick[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsCandlesticksAsync
     *
     * Get options candlesticks
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsCandlesticksAsync($associative_array)
    {
        return $this->listOptionsCandlesticksAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsCandlesticksAsyncWithHttpInfo
     *
     * Get options candlesticks
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsCandlesticksAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsCandlestick[]';
        $request = $this->listOptionsCandlesticksRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsCandlesticks'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsCandlesticksRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '5m';

        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listOptionsCandlesticks'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsCandlesticks, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsCandlesticks, must be bigger than or equal to 1.');
        }


        $resourcePath = '/options/candlesticks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsUnderlyingCandlesticks
     *
     * Mark price candlesticks of an underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesCandlestick[]
     */
    public function listOptionsUnderlyingCandlesticks($associative_array)
    {
        list($response) = $this->listOptionsUnderlyingCandlesticksWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsUnderlyingCandlesticksWithHttpInfo
     *
     * Mark price candlesticks of an underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesCandlestick[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsUnderlyingCandlesticksWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsUnderlyingCandlesticksRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesCandlestick[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsUnderlyingCandlesticksAsync
     *
     * Mark price candlesticks of an underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsUnderlyingCandlesticksAsync($associative_array)
    {
        return $this->listOptionsUnderlyingCandlesticksAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsUnderlyingCandlesticksAsyncWithHttpInfo
     *
     * Mark price candlesticks of an underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsUnderlyingCandlesticksAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesCandlestick[]';
        $request = $this->listOptionsUnderlyingCandlesticksRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsUnderlyingCandlesticks'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $interval Interval time between data points (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsUnderlyingCandlesticksRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '5m';

        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsUnderlyingCandlesticks'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsUnderlyingCandlesticks, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsUnderlyingCandlesticks, must be bigger than or equal to 1.');
        }


        $resourcePath = '/options/underlying/candlesticks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsTrades
     *
     * Options trade history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $type &#x60;C&#x60; is call, while &#x60;P&#x60; is put (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesTrade[]
     */
    public function listOptionsTrades($associative_array)
    {
        list($response) = $this->listOptionsTradesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsTradesWithHttpInfo
     *
     * Options trade history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $type &#x60;C&#x60; is call, while &#x60;P&#x60; is put (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesTrade[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsTradesWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsTradesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesTrade[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsTradesAsync
     *
     * Options trade history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $type &#x60;C&#x60; is call, while &#x60;P&#x60; is put (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsTradesAsync($associative_array)
    {
        return $this->listOptionsTradesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsTradesAsyncWithHttpInfo
     *
     * Options trade history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $type &#x60;C&#x60; is call, while &#x60;P&#x60; is put (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsTradesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesTrade[]';
        $request = $this->listOptionsTradesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsTrades'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $type &#x60;C&#x60; is call, while &#x60;P&#x60; is put (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsTradesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $type = array_key_exists('type', $associative_array) ? $associative_array['type'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsTrades, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsTrades, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling OptionsApi.listOptionsTrades, must be bigger than or equal to 0.');
        }


        $resourcePath = '/options/trades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsAccount
     *
     * List options account
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsAccount
     */
    public function listOptionsAccount()
    {
        list($response) = $this->listOptionsAccountWithHttpInfo();
        return $response;
    }

    /**
     * Operation listOptionsAccountWithHttpInfo
     *
     * List options account
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsAccountWithHttpInfo()
    {
        $request = $this->listOptionsAccountRequest();

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsAccount';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsAccountAsync
     *
     * List options account
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsAccountAsync()
    {
        return $this->listOptionsAccountAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsAccountAsyncWithHttpInfo
     *
     * List options account
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsAccountAsyncWithHttpInfo()
    {
        $returnType = '\GateApi\Model\OptionsAccount';
        $request = $this->listOptionsAccountRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsAccount'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsAccountRequest()
    {

        $resourcePath = '/options/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsAccountBook
     *
     * List account changing history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type: - dnw: Deposit &amp; Withdraw - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: settlement PNL (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsAccountBook[]
     */
    public function listOptionsAccountBook($associative_array)
    {
        list($response) = $this->listOptionsAccountBookWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsAccountBookWithHttpInfo
     *
     * List account changing history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type: - dnw: Deposit &amp; Withdraw - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: settlement PNL (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsAccountBook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsAccountBookWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsAccountBookRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsAccountBook[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsAccountBookAsync
     *
     * List account changing history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type: - dnw: Deposit &amp; Withdraw - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: settlement PNL (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsAccountBookAsync($associative_array)
    {
        return $this->listOptionsAccountBookAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsAccountBookAsyncWithHttpInfo
     *
     * List account changing history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type: - dnw: Deposit &amp; Withdraw - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: settlement PNL (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsAccountBookAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsAccountBook[]';
        $request = $this->listOptionsAccountBookRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsAccountBook'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type: - dnw: Deposit &amp; Withdraw - prem: Trading premium - fee: Trading fee - refr: Referrer rebate - set: settlement PNL (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsAccountBookRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $type = array_key_exists('type', $associative_array) ? $associative_array['type'] : null;

        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsAccountBook, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsAccountBook, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling OptionsApi.listOptionsAccountBook, must be bigger than or equal to 0.');
        }


        $resourcePath = '/options/account_book';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsPositions
     *
     * List user's positions of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsPosition[]
     */
    public function listOptionsPositions($associative_array)
    {
        list($response) = $this->listOptionsPositionsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsPositionsWithHttpInfo
     *
     * List user's positions of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsPosition[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsPositionsWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsPositionsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsPosition[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsPositionsAsync
     *
     * List user's positions of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsPositionsAsync($associative_array)
    {
        return $this->listOptionsPositionsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsPositionsAsyncWithHttpInfo
     *
     * List user's positions of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsPositionsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsPosition[]';
        $request = $this->listOptionsPositionsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsPositions'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsPositionsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;


        $resourcePath = '/options/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOptionsPosition
     *
     * Get specified contract position
     *
     * @param  string $contract contract (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsPosition
     */
    public function getOptionsPosition($contract)
    {
        list($response) = $this->getOptionsPositionWithHttpInfo($contract);
        return $response;
    }

    /**
     * Operation getOptionsPositionWithHttpInfo
     *
     * Get specified contract position
     *
     * @param  string $contract (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOptionsPositionWithHttpInfo($contract)
    {
        $request = $this->getOptionsPositionRequest($contract);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsPosition';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getOptionsPositionAsync
     *
     * Get specified contract position
     *
     * @param  string $contract (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsPositionAsync($contract)
    {
        return $this->getOptionsPositionAsyncWithHttpInfo($contract)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOptionsPositionAsyncWithHttpInfo
     *
     * Get specified contract position
     *
     * @param  string $contract (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsPositionAsyncWithHttpInfo($contract)
    {
        $returnType = '\GateApi\Model\OptionsPosition';
        $request = $this->getOptionsPositionRequest($contract);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOptionsPosition'
     *
     * @param  string $contract (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOptionsPositionRequest($contract)
    {
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling getOptionsPosition'
            );
        }

        $resourcePath = '/options/positions/{contract}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsPositionClose
     *
     * List user's liquidation history of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsPositionClose[]
     */
    public function listOptionsPositionClose($associative_array)
    {
        list($response) = $this->listOptionsPositionCloseWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsPositionCloseWithHttpInfo
     *
     * List user's liquidation history of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsPositionClose[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsPositionCloseWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsPositionCloseRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsPositionClose[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsPositionCloseAsync
     *
     * List user's liquidation history of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsPositionCloseAsync($associative_array)
    {
        return $this->listOptionsPositionCloseAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsPositionCloseAsyncWithHttpInfo
     *
     * List user's liquidation history of specified underlying
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsPositionCloseAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsPositionClose[]';
        $request = $this->listOptionsPositionCloseRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsPositionClose'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsPositionCloseRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;

        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listOptionsPositionClose'
            );
        }

        $resourcePath = '/options/position_close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listOptionsOrders
     *
     * List options orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Only list the orders with this status (required)
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsOrder[]
     */
    public function listOptionsOrders($associative_array)
    {
        list($response) = $this->listOptionsOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listOptionsOrdersWithHttpInfo
     *
     * List options orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Only list the orders with this status (required)
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listOptionsOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listOptionsOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listOptionsOrdersAsync
     *
     * List options orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Only list the orders with this status (required)
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsOrdersAsync($associative_array)
    {
        return $this->listOptionsOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listOptionsOrdersAsyncWithHttpInfo
     *
     * List options orders
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Only list the orders with this status (required)
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listOptionsOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsOrder[]';
        $request = $this->listOptionsOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listOptionsOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Only list the orders with this status (required)
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listOptionsOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $status = array_key_exists('status', $associative_array) ? $associative_array['status'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling listOptionsOrders'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsOrders, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listOptionsOrders, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling OptionsApi.listOptionsOrders, must be bigger than or equal to 0.');
        }


        $resourcePath = '/options/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOptionsOrder
     *
     * Create an options order
     *
     * @param  \GateApi\Model\OptionsOrder $options_order options_order (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsOrder
     */
    public function createOptionsOrder($options_order)
    {
        list($response) = $this->createOptionsOrderWithHttpInfo($options_order);
        return $response;
    }

    /**
     * Operation createOptionsOrderWithHttpInfo
     *
     * Create an options order
     *
     * @param  \GateApi\Model\OptionsOrder $options_order (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOptionsOrderWithHttpInfo($options_order)
    {
        $request = $this->createOptionsOrderRequest($options_order);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createOptionsOrderAsync
     *
     * Create an options order
     *
     * @param  \GateApi\Model\OptionsOrder $options_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOptionsOrderAsync($options_order)
    {
        return $this->createOptionsOrderAsyncWithHttpInfo($options_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOptionsOrderAsyncWithHttpInfo
     *
     * Create an options order
     *
     * @param  \GateApi\Model\OptionsOrder $options_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOptionsOrderAsyncWithHttpInfo($options_order)
    {
        $returnType = '\GateApi\Model\OptionsOrder';
        $request = $this->createOptionsOrderRequest($options_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOptionsOrder'
     *
     * @param  \GateApi\Model\OptionsOrder $options_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOptionsOrderRequest($options_order)
    {
        // verify the required parameter 'options_order' is set
        if ($options_order === null || (is_array($options_order) && count($options_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $options_order when calling createOptionsOrder'
            );
        }

        $resourcePath = '/options/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($options_order)) {
            $_tempBody = $options_order;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelOptionsOrders
     *
     * Cancel all `open` orders matched
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  string $side All bids or asks. Both included if not specified (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsOrder[]
     */
    public function cancelOptionsOrders($contract = null, $underlying = null, $side = null)
    {
        list($response) = $this->cancelOptionsOrdersWithHttpInfo($contract, $underlying, $side);
        return $response;
    }

    /**
     * Operation cancelOptionsOrdersWithHttpInfo
     *
     * Cancel all `open` orders matched
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  string $side All bids or asks. Both included if not specified (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelOptionsOrdersWithHttpInfo($contract = null, $underlying = null, $side = null)
    {
        $request = $this->cancelOptionsOrdersRequest($contract, $underlying, $side);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelOptionsOrdersAsync
     *
     * Cancel all `open` orders matched
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  string $side All bids or asks. Both included if not specified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOptionsOrdersAsync($contract = null, $underlying = null, $side = null)
    {
        return $this->cancelOptionsOrdersAsyncWithHttpInfo($contract, $underlying, $side)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelOptionsOrdersAsyncWithHttpInfo
     *
     * Cancel all `open` orders matched
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  string $side All bids or asks. Both included if not specified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOptionsOrdersAsyncWithHttpInfo($contract = null, $underlying = null, $side = null)
    {
        $returnType = '\GateApi\Model\OptionsOrder[]';
        $request = $this->cancelOptionsOrdersRequest($contract, $underlying, $side);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelOptionsOrders'
     *
     * @param  string $contract Options contract name (optional)
     * @param  string $underlying Underlying (optional)
     * @param  string $side All bids or asks. Both included if not specified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelOptionsOrdersRequest($contract = null, $underlying = null, $side = null)
    {

        $resourcePath = '/options/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($side !== null) {
            if('form' === 'form' && is_array($side)) {
                foreach($side as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['side'] = $side;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOptionsOrder
     *
     * Get a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsOrder
     */
    public function getOptionsOrder($order_id)
    {
        list($response) = $this->getOptionsOrderWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation getOptionsOrderWithHttpInfo
     *
     * Get a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOptionsOrderWithHttpInfo($order_id)
    {
        $request = $this->getOptionsOrderRequest($order_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getOptionsOrderAsync
     *
     * Get a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsOrderAsync($order_id)
    {
        return $this->getOptionsOrderAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOptionsOrderAsyncWithHttpInfo
     *
     * Get a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsOrderAsyncWithHttpInfo($order_id)
    {
        $returnType = '\GateApi\Model\OptionsOrder';
        $request = $this->getOptionsOrderRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOptionsOrder'
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOptionsOrderRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getOptionsOrder'
            );
        }

        $resourcePath = '/options/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelOptionsOrder
     *
     * Cancel a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsOrder
     */
    public function cancelOptionsOrder($order_id)
    {
        list($response) = $this->cancelOptionsOrderWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation cancelOptionsOrderWithHttpInfo
     *
     * Cancel a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelOptionsOrderWithHttpInfo($order_id)
    {
        $request = $this->cancelOptionsOrderRequest($order_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelOptionsOrderAsync
     *
     * Cancel a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOptionsOrderAsync($order_id)
    {
        return $this->cancelOptionsOrderAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelOptionsOrderAsyncWithHttpInfo
     *
     * Cancel a single order
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOptionsOrderAsyncWithHttpInfo($order_id)
    {
        $returnType = '\GateApi\Model\OptionsOrder';
        $request = $this->cancelOptionsOrderRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelOptionsOrder'
     *
     * @param  int $order_id Order ID returned on successful order creation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelOptionsOrderRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling cancelOptionsOrder'
            );
        }

        $resourcePath = '/options/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation countdownCancelAllOptions
     *
     * Countdown cancel orders
     *
     * @param  \GateApi\Model\CountdownCancelAllOptionsTask $countdown_cancel_all_options_task countdown_cancel_all_options_task (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\TriggerTime
     */
    public function countdownCancelAllOptions($countdown_cancel_all_options_task)
    {
        list($response) = $this->countdownCancelAllOptionsWithHttpInfo($countdown_cancel_all_options_task);
        return $response;
    }

    /**
     * Operation countdownCancelAllOptionsWithHttpInfo
     *
     * Countdown cancel orders
     *
     * @param  \GateApi\Model\CountdownCancelAllOptionsTask $countdown_cancel_all_options_task (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\TriggerTime, HTTP status code, HTTP response headers (array of strings)
     */
    public function countdownCancelAllOptionsWithHttpInfo($countdown_cancel_all_options_task)
    {
        $request = $this->countdownCancelAllOptionsRequest($countdown_cancel_all_options_task);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\TriggerTime';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation countdownCancelAllOptionsAsync
     *
     * Countdown cancel orders
     *
     * @param  \GateApi\Model\CountdownCancelAllOptionsTask $countdown_cancel_all_options_task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countdownCancelAllOptionsAsync($countdown_cancel_all_options_task)
    {
        return $this->countdownCancelAllOptionsAsyncWithHttpInfo($countdown_cancel_all_options_task)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countdownCancelAllOptionsAsyncWithHttpInfo
     *
     * Countdown cancel orders
     *
     * @param  \GateApi\Model\CountdownCancelAllOptionsTask $countdown_cancel_all_options_task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countdownCancelAllOptionsAsyncWithHttpInfo($countdown_cancel_all_options_task)
    {
        $returnType = '\GateApi\Model\TriggerTime';
        $request = $this->countdownCancelAllOptionsRequest($countdown_cancel_all_options_task);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'countdownCancelAllOptions'
     *
     * @param  \GateApi\Model\CountdownCancelAllOptionsTask $countdown_cancel_all_options_task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function countdownCancelAllOptionsRequest($countdown_cancel_all_options_task)
    {
        // verify the required parameter 'countdown_cancel_all_options_task' is set
        if ($countdown_cancel_all_options_task === null || (is_array($countdown_cancel_all_options_task) && count($countdown_cancel_all_options_task) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $countdown_cancel_all_options_task when calling countdownCancelAllOptions'
            );
        }

        $resourcePath = '/options/countdown_cancel_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($countdown_cancel_all_options_task)) {
            $_tempBody = $countdown_cancel_all_options_task;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMyOptionsTrades
     *
     * List personal trading history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsMyTrade[]
     */
    public function listMyOptionsTrades($associative_array)
    {
        list($response) = $this->listMyOptionsTradesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listMyOptionsTradesWithHttpInfo
     *
     * List personal trading history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsMyTrade[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listMyOptionsTradesWithHttpInfo($associative_array)
    {
        $request = $this->listMyOptionsTradesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsMyTrade[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listMyOptionsTradesAsync
     *
     * List personal trading history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMyOptionsTradesAsync($associative_array)
    {
        return $this->listMyOptionsTradesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMyOptionsTradesAsyncWithHttpInfo
     *
     * List personal trading history
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMyOptionsTradesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsMyTrade[]';
        $request = $this->listMyOptionsTradesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMyOptionsTrades'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (Obtained by listing underlying endpoint) (required)
     * @param  string $contract Options contract name (optional)
     * @param  int $limit Maximum number of records to be returned in a single list (optional, default to 100)
     * @param  int $offset List offset, starting from 0 (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMyOptionsTradesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        // verify the required parameter 'underlying' is set
        if ($underlying === null || (is_array($underlying) && count($underlying) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $underlying when calling listMyOptionsTrades'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listMyOptionsTrades, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OptionsApi.listMyOptionsTrades, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling OptionsApi.listMyOptionsTrades, must be bigger than or equal to 0.');
        }


        $resourcePath = '/options/my_trades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOptionsMMP
     *
     * MMP Query
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsMMP[]
     */
    public function getOptionsMMP($associative_array)
    {
        list($response) = $this->getOptionsMMPWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getOptionsMMPWithHttpInfo
     *
     * MMP Query
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsMMP[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOptionsMMPWithHttpInfo($associative_array)
    {
        $request = $this->getOptionsMMPRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsMMP[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getOptionsMMPAsync
     *
     * MMP Query
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsMMPAsync($associative_array)
    {
        return $this->getOptionsMMPAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOptionsMMPAsyncWithHttpInfo
     *
     * MMP Query
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOptionsMMPAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\OptionsMMP[]';
        $request = $this->getOptionsMMPRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOptionsMMP'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $underlying Underlying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOptionsMMPRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $underlying = array_key_exists('underlying', $associative_array) ? $associative_array['underlying'] : null;


        $resourcePath = '/options/mmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($underlying !== null) {
            if('form' === 'form' && is_array($underlying)) {
                foreach($underlying as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['underlying'] = $underlying;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setOptionsMMP
     *
     * MMP Settings
     *
     * @param  \GateApi\Model\OptionsMMP $options_mmp options_mmp (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsMMP
     */
    public function setOptionsMMP($options_mmp)
    {
        list($response) = $this->setOptionsMMPWithHttpInfo($options_mmp);
        return $response;
    }

    /**
     * Operation setOptionsMMPWithHttpInfo
     *
     * MMP Settings
     *
     * @param  \GateApi\Model\OptionsMMP $options_mmp (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsMMP, HTTP status code, HTTP response headers (array of strings)
     */
    public function setOptionsMMPWithHttpInfo($options_mmp)
    {
        $request = $this->setOptionsMMPRequest($options_mmp);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsMMP';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation setOptionsMMPAsync
     *
     * MMP Settings
     *
     * @param  \GateApi\Model\OptionsMMP $options_mmp (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setOptionsMMPAsync($options_mmp)
    {
        return $this->setOptionsMMPAsyncWithHttpInfo($options_mmp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setOptionsMMPAsyncWithHttpInfo
     *
     * MMP Settings
     *
     * @param  \GateApi\Model\OptionsMMP $options_mmp (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setOptionsMMPAsyncWithHttpInfo($options_mmp)
    {
        $returnType = '\GateApi\Model\OptionsMMP';
        $request = $this->setOptionsMMPRequest($options_mmp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setOptionsMMP'
     *
     * @param  \GateApi\Model\OptionsMMP $options_mmp (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setOptionsMMPRequest($options_mmp)
    {
        // verify the required parameter 'options_mmp' is set
        if ($options_mmp === null || (is_array($options_mmp) && count($options_mmp) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $options_mmp when calling setOptionsMMP'
            );
        }

        $resourcePath = '/options/mmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($options_mmp)) {
            $_tempBody = $options_mmp;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetOptionsMMP
     *
     * MMP Reset
     *
     * @param  \GateApi\Model\OptionsMMPReset $options_mmp_reset options_mmp_reset (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\OptionsMMP
     */
    public function resetOptionsMMP($options_mmp_reset)
    {
        list($response) = $this->resetOptionsMMPWithHttpInfo($options_mmp_reset);
        return $response;
    }

    /**
     * Operation resetOptionsMMPWithHttpInfo
     *
     * MMP Reset
     *
     * @param  \GateApi\Model\OptionsMMPReset $options_mmp_reset (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\OptionsMMP, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetOptionsMMPWithHttpInfo($options_mmp_reset)
    {
        $request = $this->resetOptionsMMPRequest($options_mmp_reset);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\OptionsMMP';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation resetOptionsMMPAsync
     *
     * MMP Reset
     *
     * @param  \GateApi\Model\OptionsMMPReset $options_mmp_reset (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetOptionsMMPAsync($options_mmp_reset)
    {
        return $this->resetOptionsMMPAsyncWithHttpInfo($options_mmp_reset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetOptionsMMPAsyncWithHttpInfo
     *
     * MMP Reset
     *
     * @param  \GateApi\Model\OptionsMMPReset $options_mmp_reset (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetOptionsMMPAsyncWithHttpInfo($options_mmp_reset)
    {
        $returnType = '\GateApi\Model\OptionsMMP';
        $request = $this->resetOptionsMMPRequest($options_mmp_reset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetOptionsMMP'
     *
     * @param  \GateApi\Model\OptionsMMPReset $options_mmp_reset (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resetOptionsMMPRequest($options_mmp_reset)
    {
        // verify the required parameter 'options_mmp_reset' is set
        if ($options_mmp_reset === null || (is_array($options_mmp_reset) && count($options_mmp_reset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $options_mmp_reset when calling resetOptionsMMP'
            );
        }

        $resourcePath = '/options/mmp/reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($options_mmp_reset)) {
            $_tempBody = $options_mmp_reset;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
