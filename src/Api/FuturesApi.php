<?php
/**
 * FuturesApi
 * PHP version 7
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */

/**
 * Gate API
 *
 * Welcome to Gate API  APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 * Generated by: https://openapi-generator.tech
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace GateApi\Api;

use GateApi\ApiException;
use GateApi\Configuration;
use GateApi\GateApiException;
use GateApi\HeaderSelector;
use GateApi\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * FuturesApi Class Doc Comment
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */
class FuturesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation listFuturesContracts
     *
     * List all futures contracts.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Contract[]
     */
    public function listFuturesContracts($associative_array)
    {
        list($response) = $this->listFuturesContractsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesContractsWithHttpInfo
     *
     * List all futures contracts.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Contract[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesContractsWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesContractsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Contract[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesContractsAsync
     *
     * List all futures contracts.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesContractsAsync($associative_array)
    {
        return $this->listFuturesContractsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesContractsAsyncWithHttpInfo
     *
     * List all futures contracts.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesContractsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\Contract[]';
        $request = $this->listFuturesContractsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesContracts'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesContractsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesContracts'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesContracts, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesContracts, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listFuturesContracts, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/contracts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFuturesContract
     *
     * Get a single contract.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Contract
     */
    public function getFuturesContract($settle, $contract)
    {
        list($response) = $this->getFuturesContractWithHttpInfo($settle, $contract);
        return $response;
    }

    /**
     * Operation getFuturesContractWithHttpInfo
     *
     * Get a single contract.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Contract, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFuturesContractWithHttpInfo($settle, $contract)
    {
        $request = $this->getFuturesContractRequest($settle, $contract);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Contract';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getFuturesContractAsync
     *
     * Get a single contract.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesContractAsync($settle, $contract)
    {
        return $this->getFuturesContractAsyncWithHttpInfo($settle, $contract)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFuturesContractAsyncWithHttpInfo
     *
     * Get a single contract.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesContractAsyncWithHttpInfo($settle, $contract)
    {
        $returnType = '\GateApi\Model\Contract';
        $request = $this->getFuturesContractRequest($settle, $contract);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFuturesContract'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFuturesContractRequest($settle, $contract)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getFuturesContract'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling getFuturesContract'
            );
        }

        $resourcePath = '/futures/{settle}/contracts/{contract}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesOrderBook
     *
     * Futures order book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0. (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids. (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrderBook
     */
    public function listFuturesOrderBook($associative_array)
    {
        list($response) = $this->listFuturesOrderBookWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesOrderBookWithHttpInfo
     *
     * Futures order book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0. (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids. (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrderBook, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesOrderBookWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesOrderBookRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrderBook';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesOrderBookAsync
     *
     * Futures order book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0. (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids. (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesOrderBookAsync($associative_array)
    {
        return $this->listFuturesOrderBookAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesOrderBookAsyncWithHttpInfo
     *
     * Futures order book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0. (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids. (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesOrderBookAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesOrderBook';
        $request = $this->listFuturesOrderBookRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesOrderBook'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $interval Order depth. 0 means no aggregation is applied. default to 0. (optional, default to '0')
     * @param  int $limit Maximum number of order depth data in asks or bids. (optional, default to 10)
     * @param  bool $with_id Whether to return depth update ID. This ID increments by 1 each time. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesOrderBookRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '0';
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 10;
        $with_id = array_key_exists('with_id', $associative_array) ? $associative_array['with_id'] : false;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesOrderBook'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listFuturesOrderBook'
            );
        }
        if ($limit !== null && $limit > 50) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesOrderBook, must be smaller than or equal to 50.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesOrderBook, must be bigger than or equal to 1.');
        }


        $resourcePath = '/futures/{settle}/order_book';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($with_id !== null) {
            if('form' === 'form' && is_array($with_id)) {
                foreach($with_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['with_id'] = $with_id;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesTrades
     *
     * Futures trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)
     * @param  int $from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned. (optional)
     * @param  int $to Specify end time in Unix seconds, default to current time. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesTrade[]
     */
    public function listFuturesTrades($associative_array)
    {
        list($response) = $this->listFuturesTradesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesTradesWithHttpInfo
     *
     * Futures trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)
     * @param  int $from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned. (optional)
     * @param  int $to Specify end time in Unix seconds, default to current time. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesTrade[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesTradesWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesTradesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesTrade[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesTradesAsync
     *
     * Futures trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)
     * @param  int $from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned. (optional)
     * @param  int $to Specify end time in Unix seconds, default to current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesTradesAsync($associative_array)
    {
        return $this->listFuturesTradesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesTradesAsyncWithHttpInfo
     *
     * Futures trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)
     * @param  int $from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned. (optional)
     * @param  int $to Specify end time in Unix seconds, default to current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesTradesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesTrade[]';
        $request = $this->listFuturesTradesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesTrades'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)
     * @param  int $from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned. (optional)
     * @param  int $to Specify end time in Unix seconds, default to current time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesTradesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $last_id = array_key_exists('last_id', $associative_array) ? $associative_array['last_id'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesTrades'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listFuturesTrades'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesTrades, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesTrades, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listFuturesTrades, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/trades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($last_id !== null) {
            if('form' === 'form' && is_array($last_id)) {
                foreach($last_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['last_id'] = $last_id;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesCandlesticks
     *
     * Get futures candlesticks.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0. 1 natual month, not 30 days (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesCandlestick[]
     */
    public function listFuturesCandlesticks($associative_array)
    {
        list($response) = $this->listFuturesCandlesticksWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesCandlesticksWithHttpInfo
     *
     * Get futures candlesticks.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0. 1 natual month, not 30 days (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesCandlestick[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesCandlesticksWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesCandlesticksRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesCandlestick[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesCandlesticksAsync
     *
     * Get futures candlesticks.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0. 1 natual month, not 30 days (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesCandlesticksAsync($associative_array)
    {
        return $this->listFuturesCandlesticksAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesCandlesticksAsyncWithHttpInfo
     *
     * Get futures candlesticks.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0. 1 natual month, not 30 days (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesCandlesticksAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesCandlestick[]';
        $request = $this->listFuturesCandlesticksRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesCandlesticks'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0. 1 natual month, not 30 days (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesCandlesticksRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '5m';

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesCandlesticks'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listFuturesCandlesticks'
            );
        }
        if ($limit !== null && $limit > 2000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesCandlesticks, must be smaller than or equal to 2000.');
        }


        $resourcePath = '/futures/{settle}/candlesticks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesPremiumIndex
     *
     * Premium Index K-Line.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesPremiumIndex[]
     */
    public function listFuturesPremiumIndex($associative_array)
    {
        list($response) = $this->listFuturesPremiumIndexWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesPremiumIndexWithHttpInfo
     *
     * Premium Index K-Line.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. (optional, default to '5m')
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesPremiumIndex[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesPremiumIndexWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesPremiumIndexRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesPremiumIndex[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesPremiumIndexAsync
     *
     * Premium Index K-Line.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesPremiumIndexAsync($associative_array)
    {
        return $this->listFuturesPremiumIndexAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesPremiumIndexAsyncWithHttpInfo
     *
     * Premium Index K-Line.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesPremiumIndexAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesPremiumIndex[]';
        $request = $this->listFuturesPremiumIndexRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesPremiumIndex'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)
     * @param  int $to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision specified (optional)
     * @param  int $limit Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)
     * @param  string $interval Interval time between data points. (optional, default to '5m')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesPremiumIndexRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '5m';

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesPremiumIndex'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listFuturesPremiumIndex'
            );
        }
        if ($limit !== null && $limit > 2000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesPremiumIndex, must be smaller than or equal to 2000.');
        }


        $resourcePath = '/futures/{settle}/premium_index';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesTickers
     *
     * List futures tickers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesTicker[]
     */
    public function listFuturesTickers($associative_array)
    {
        list($response) = $this->listFuturesTickersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesTickersWithHttpInfo
     *
     * List futures tickers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesTicker[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesTickersWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesTickersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesTicker[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesTickersAsync
     *
     * List futures tickers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesTickersAsync($associative_array)
    {
        return $this->listFuturesTickersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesTickersAsyncWithHttpInfo
     *
     * List futures tickers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesTickersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesTicker[]';
        $request = $this->listFuturesTickersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesTickers'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesTickersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesTickers'
            );
        }

        $resourcePath = '/futures/{settle}/tickers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesFundingRateHistory
     *
     * Funding rate history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FundingRateRecord[]
     */
    public function listFuturesFundingRateHistory($associative_array)
    {
        list($response) = $this->listFuturesFundingRateHistoryWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesFundingRateHistoryWithHttpInfo
     *
     * Funding rate history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FundingRateRecord[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesFundingRateHistoryWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesFundingRateHistoryRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FundingRateRecord[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesFundingRateHistoryAsync
     *
     * Funding rate history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesFundingRateHistoryAsync($associative_array)
    {
        return $this->listFuturesFundingRateHistoryAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesFundingRateHistoryAsyncWithHttpInfo
     *
     * Funding rate history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesFundingRateHistoryAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FundingRateRecord[]';
        $request = $this->listFuturesFundingRateHistoryRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesFundingRateHistory'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesFundingRateHistoryRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesFundingRateHistory'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listFuturesFundingRateHistory'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesFundingRateHistory, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesFundingRateHistory, must be bigger than or equal to 1.');
        }


        $resourcePath = '/futures/{settle}/funding_rate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesInsuranceLedger
     *
     * Futures insurance balance history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\InsuranceRecord[]
     */
    public function listFuturesInsuranceLedger($associative_array)
    {
        list($response) = $this->listFuturesInsuranceLedgerWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesInsuranceLedgerWithHttpInfo
     *
     * Futures insurance balance history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\InsuranceRecord[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesInsuranceLedgerWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesInsuranceLedgerRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\InsuranceRecord[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesInsuranceLedgerAsync
     *
     * Futures insurance balance history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesInsuranceLedgerAsync($associative_array)
    {
        return $this->listFuturesInsuranceLedgerAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesInsuranceLedgerAsyncWithHttpInfo
     *
     * Futures insurance balance history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesInsuranceLedgerAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\InsuranceRecord[]';
        $request = $this->listFuturesInsuranceLedgerRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesInsuranceLedger'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesInsuranceLedgerRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesInsuranceLedger'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesInsuranceLedger, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesInsuranceLedger, must be bigger than or equal to 1.');
        }


        $resourcePath = '/futures/{settle}/insurance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listContractStats
     *
     * Futures stats.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start timestamp. (optional)
     * @param  string $interval interval (optional, default to '5m')
     * @param  int $limit limit (optional, default to 30)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\ContractStat[]
     */
    public function listContractStats($associative_array)
    {
        list($response) = $this->listContractStatsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listContractStatsWithHttpInfo
     *
     * Futures stats.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start timestamp. (optional)
     * @param  string $interval (optional, default to '5m')
     * @param  int $limit (optional, default to 30)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\ContractStat[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listContractStatsWithHttpInfo($associative_array)
    {
        $request = $this->listContractStatsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\ContractStat[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listContractStatsAsync
     *
     * Futures stats.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start timestamp. (optional)
     * @param  string $interval (optional, default to '5m')
     * @param  int $limit (optional, default to 30)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractStatsAsync($associative_array)
    {
        return $this->listContractStatsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listContractStatsAsyncWithHttpInfo
     *
     * Futures stats.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start timestamp. (optional)
     * @param  string $interval (optional, default to '5m')
     * @param  int $limit (optional, default to 30)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractStatsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\ContractStat[]';
        $request = $this->listContractStatsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listContractStats'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  int $from Start timestamp. (optional)
     * @param  string $interval (optional, default to '5m')
     * @param  int $limit (optional, default to 30)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listContractStatsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $interval = array_key_exists('interval', $associative_array) ? $associative_array['interval'] : '5m';
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 30;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listContractStats'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling listContractStats'
            );
        }
        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listContractStats, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listContractStats, must be bigger than or equal to 1.');
        }


        $resourcePath = '/futures/{settle}/contract_stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($interval !== null) {
            if('form' === 'form' && is_array($interval)) {
                foreach($interval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['interval'] = $interval;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIndexConstituents
     *
     * Get index constituents.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $index Index name. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesIndexConstituents
     */
    public function getIndexConstituents($settle, $index)
    {
        list($response) = $this->getIndexConstituentsWithHttpInfo($settle, $index);
        return $response;
    }

    /**
     * Operation getIndexConstituentsWithHttpInfo
     *
     * Get index constituents.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $index Index name. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesIndexConstituents, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIndexConstituentsWithHttpInfo($settle, $index)
    {
        $request = $this->getIndexConstituentsRequest($settle, $index);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesIndexConstituents';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getIndexConstituentsAsync
     *
     * Get index constituents.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $index Index name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIndexConstituentsAsync($settle, $index)
    {
        return $this->getIndexConstituentsAsyncWithHttpInfo($settle, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIndexConstituentsAsyncWithHttpInfo
     *
     * Get index constituents.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $index Index name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIndexConstituentsAsyncWithHttpInfo($settle, $index)
    {
        $returnType = '\GateApi\Model\FuturesIndexConstituents';
        $request = $this->getIndexConstituentsRequest($settle, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIndexConstituents'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $index Index name. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIndexConstituentsRequest($settle, $index)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getIndexConstituents'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling getIndexConstituents'
            );
        }

        $resourcePath = '/futures/{settle}/index_constituents/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLiquidatedOrders
     *
     * Retrieve liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesLiqOrder[]
     */
    public function listLiquidatedOrders($associative_array)
    {
        list($response) = $this->listLiquidatedOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listLiquidatedOrdersWithHttpInfo
     *
     * Retrieve liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesLiqOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLiquidatedOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listLiquidatedOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesLiqOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listLiquidatedOrdersAsync
     *
     * Retrieve liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLiquidatedOrdersAsync($associative_array)
    {
        return $this->listLiquidatedOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLiquidatedOrdersAsyncWithHttpInfo
     *
     * Retrieve liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLiquidatedOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesLiqOrder[]';
        $request = $this->listLiquidatedOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLiquidatedOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLiquidatedOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listLiquidatedOrders'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listLiquidatedOrders, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listLiquidatedOrders, must be bigger than or equal to 1.');
        }


        $resourcePath = '/futures/{settle}/liq_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesRiskLimitTiers
     *
     * List risk limit tiers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesLimitRiskTiers[]
     */
    public function listFuturesRiskLimitTiers($associative_array)
    {
        list($response) = $this->listFuturesRiskLimitTiersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesRiskLimitTiersWithHttpInfo
     *
     * List risk limit tiers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesLimitRiskTiers[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesRiskLimitTiersWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesRiskLimitTiersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesLimitRiskTiers[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesRiskLimitTiersAsync
     *
     * List risk limit tiers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesRiskLimitTiersAsync($associative_array)
    {
        return $this->listFuturesRiskLimitTiersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesRiskLimitTiersAsyncWithHttpInfo
     *
     * List risk limit tiers.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesRiskLimitTiersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesLimitRiskTiers[]';
        $request = $this->listFuturesRiskLimitTiersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesRiskLimitTiers'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesRiskLimitTiersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesRiskLimitTiers'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesRiskLimitTiers, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesRiskLimitTiers, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listFuturesRiskLimitTiers, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/risk_limit_tiers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesAccounts
     *
     * Query futures account.
     *
     * @param  string $settle Settle currency. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesAccount
     */
    public function listFuturesAccounts($settle)
    {
        list($response) = $this->listFuturesAccountsWithHttpInfo($settle);
        return $response;
    }

    /**
     * Operation listFuturesAccountsWithHttpInfo
     *
     * Query futures account.
     *
     * @param  string $settle Settle currency. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesAccountsWithHttpInfo($settle)
    {
        $request = $this->listFuturesAccountsRequest($settle);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesAccount';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesAccountsAsync
     *
     * Query futures account.
     *
     * @param  string $settle Settle currency. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesAccountsAsync($settle)
    {
        return $this->listFuturesAccountsAsyncWithHttpInfo($settle)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesAccountsAsyncWithHttpInfo
     *
     * Query futures account.
     *
     * @param  string $settle Settle currency. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesAccountsAsyncWithHttpInfo($settle)
    {
        $returnType = '\GateApi\Model\FuturesAccount';
        $request = $this->listFuturesAccountsRequest($settle);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesAccounts'
     *
     * @param  string $settle Settle currency. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesAccountsRequest($settle)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesAccounts'
            );
        }

        $resourcePath = '/futures/{settle}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesAccountBook
     *
     * Query account book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesAccountBook[]
     */
    public function listFuturesAccountBook($associative_array)
    {
        list($response) = $this->listFuturesAccountBookWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesAccountBookWithHttpInfo
     *
     * Query account book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesAccountBook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesAccountBookWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesAccountBookRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesAccountBook[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesAccountBookAsync
     *
     * Query account book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesAccountBookAsync($associative_array)
    {
        return $this->listFuturesAccountBookAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesAccountBookAsyncWithHttpInfo
     *
     * Query account book.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesAccountBookAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesAccountBook[]';
        $request = $this->listFuturesAccountBookRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesAccountBook'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $type Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesAccountBookRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $type = array_key_exists('type', $associative_array) ? $associative_array['type'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesAccountBook'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesAccountBook, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesAccountBook, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listFuturesAccountBook, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/account_book';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPositions
     *
     * List all positions of a user.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $holding Return only real positions - true, return all - false. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position[]
     */
    public function listPositions($associative_array)
    {
        list($response) = $this->listPositionsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listPositionsWithHttpInfo
     *
     * List all positions of a user.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $holding Return only real positions - true, return all - false. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listPositionsWithHttpInfo($associative_array)
    {
        $request = $this->listPositionsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listPositionsAsync
     *
     * List all positions of a user.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $holding Return only real positions - true, return all - false. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPositionsAsync($associative_array)
    {
        return $this->listPositionsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPositionsAsyncWithHttpInfo
     *
     * List all positions of a user.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $holding Return only real positions - true, return all - false. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPositionsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\Position[]';
        $request = $this->listPositionsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPositions'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $holding Return only real positions - true, return all - false. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPositionsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $holding = array_key_exists('holding', $associative_array) ? $associative_array['holding'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listPositions'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listPositions, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listPositions, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listPositions, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($holding !== null) {
            if('form' === 'form' && is_array($holding)) {
                foreach($holding as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['holding'] = $holding;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPosition
     *
     * Get single position.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position
     */
    public function getPosition($associative_array)
    {
        list($response) = $this->getPositionWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPositionWithHttpInfo
     *
     * Get single position.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPositionWithHttpInfo($associative_array)
    {
        $request = $this->getPositionRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getPositionAsync
     *
     * Get single position.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPositionAsync($associative_array)
    {
        return $this->getPositionAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPositionAsyncWithHttpInfo
     *
     * Get single position.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPositionAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\Position';
        $request = $this->getPositionRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPosition'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPositionRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getPosition'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling getPosition'
            );
        }

        $resourcePath = '/futures/{settle}/positions/{contract}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePositionMargin
     *
     * Update position margin.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position
     */
    public function updatePositionMargin($settle, $contract, $change)
    {
        list($response) = $this->updatePositionMarginWithHttpInfo($settle, $contract, $change);
        return $response;
    }

    /**
     * Operation updatePositionMarginWithHttpInfo
     *
     * Update position margin.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePositionMarginWithHttpInfo($settle, $contract, $change)
    {
        $request = $this->updatePositionMarginRequest($settle, $contract, $change);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updatePositionMarginAsync
     *
     * Update position margin.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionMarginAsync($settle, $contract, $change)
    {
        return $this->updatePositionMarginAsyncWithHttpInfo($settle, $contract, $change)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePositionMarginAsyncWithHttpInfo
     *
     * Update position margin.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionMarginAsyncWithHttpInfo($settle, $contract, $change)
    {
        $returnType = '\GateApi\Model\Position';
        $request = $this->updatePositionMarginRequest($settle, $contract, $change);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePositionMargin'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePositionMarginRequest($settle, $contract, $change)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updatePositionMargin'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling updatePositionMargin'
            );
        }
        // verify the required parameter 'change' is set
        if ($change === null || (is_array($change) && count($change) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change when calling updatePositionMargin'
            );
        }

        $resourcePath = '/futures/{settle}/positions/{contract}/margin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($change !== null) {
            if('form' === 'form' && is_array($change)) {
                foreach($change as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['change'] = $change;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePositionLeverage
     *
     * Update position leverage.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position
     */
    public function updatePositionLeverage($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        list($response) = $this->updatePositionLeverageWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit);
        return $response;
    }

    /**
     * Operation updatePositionLeverageWithHttpInfo
     *
     * Update position leverage.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePositionLeverageWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        $request = $this->updatePositionLeverageRequest($settle, $contract, $leverage, $cross_leverage_limit);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updatePositionLeverageAsync
     *
     * Update position leverage.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionLeverageAsync($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        return $this->updatePositionLeverageAsyncWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePositionLeverageAsyncWithHttpInfo
     *
     * Update position leverage.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionLeverageAsyncWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        $returnType = '\GateApi\Model\Position';
        $request = $this->updatePositionLeverageRequest($settle, $contract, $leverage, $cross_leverage_limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePositionLeverage'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePositionLeverageRequest($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updatePositionLeverage'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling updatePositionLeverage'
            );
        }
        // verify the required parameter 'leverage' is set
        if ($leverage === null || (is_array($leverage) && count($leverage) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $leverage when calling updatePositionLeverage'
            );
        }

        $resourcePath = '/futures/{settle}/positions/{contract}/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($leverage !== null) {
            if('form' === 'form' && is_array($leverage)) {
                foreach($leverage as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['leverage'] = $leverage;
            }
        }

        // query params
        if ($cross_leverage_limit !== null) {
            if('form' === 'form' && is_array($cross_leverage_limit)) {
                foreach($cross_leverage_limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cross_leverage_limit'] = $cross_leverage_limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePositionCrossMode
     *
     * Switch to the full position-by-store mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPositionCrossMode $futures_position_cross_mode futures_position_cross_mode (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position
     */
    public function updatePositionCrossMode($settle, $futures_position_cross_mode)
    {
        list($response) = $this->updatePositionCrossModeWithHttpInfo($settle, $futures_position_cross_mode);
        return $response;
    }

    /**
     * Operation updatePositionCrossModeWithHttpInfo
     *
     * Switch to the full position-by-store mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPositionCrossMode $futures_position_cross_mode (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePositionCrossModeWithHttpInfo($settle, $futures_position_cross_mode)
    {
        $request = $this->updatePositionCrossModeRequest($settle, $futures_position_cross_mode);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updatePositionCrossModeAsync
     *
     * Switch to the full position-by-store mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPositionCrossMode $futures_position_cross_mode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionCrossModeAsync($settle, $futures_position_cross_mode)
    {
        return $this->updatePositionCrossModeAsyncWithHttpInfo($settle, $futures_position_cross_mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePositionCrossModeAsyncWithHttpInfo
     *
     * Switch to the full position-by-store mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPositionCrossMode $futures_position_cross_mode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionCrossModeAsyncWithHttpInfo($settle, $futures_position_cross_mode)
    {
        $returnType = '\GateApi\Model\Position';
        $request = $this->updatePositionCrossModeRequest($settle, $futures_position_cross_mode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePositionCrossMode'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPositionCrossMode $futures_position_cross_mode (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePositionCrossModeRequest($settle, $futures_position_cross_mode)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updatePositionCrossMode'
            );
        }
        // verify the required parameter 'futures_position_cross_mode' is set
        if ($futures_position_cross_mode === null || (is_array($futures_position_cross_mode) && count($futures_position_cross_mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $futures_position_cross_mode when calling updatePositionCrossMode'
            );
        }

        $resourcePath = '/futures/{settle}/positions/cross_mode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($futures_position_cross_mode)) {
            $_tempBody = $futures_position_cross_mode;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDualCompPositionCrossMode
     *
     * 双仓模式下切换全逐仓模式
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\InlineObject $inline_object inline_object (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position[]
     */
    public function updateDualCompPositionCrossMode($settle, $inline_object)
    {
        list($response) = $this->updateDualCompPositionCrossModeWithHttpInfo($settle, $inline_object);
        return $response;
    }

    /**
     * Operation updateDualCompPositionCrossModeWithHttpInfo
     *
     * 双仓模式下切换全逐仓模式
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\InlineObject $inline_object (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDualCompPositionCrossModeWithHttpInfo($settle, $inline_object)
    {
        $request = $this->updateDualCompPositionCrossModeRequest($settle, $inline_object);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateDualCompPositionCrossModeAsync
     *
     * 双仓模式下切换全逐仓模式
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\InlineObject $inline_object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualCompPositionCrossModeAsync($settle, $inline_object)
    {
        return $this->updateDualCompPositionCrossModeAsyncWithHttpInfo($settle, $inline_object)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDualCompPositionCrossModeAsyncWithHttpInfo
     *
     * 双仓模式下切换全逐仓模式
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\InlineObject $inline_object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualCompPositionCrossModeAsyncWithHttpInfo($settle, $inline_object)
    {
        $returnType = '\GateApi\Model\Position[]';
        $request = $this->updateDualCompPositionCrossModeRequest($settle, $inline_object);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDualCompPositionCrossMode'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\InlineObject $inline_object (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDualCompPositionCrossModeRequest($settle, $inline_object)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updateDualCompPositionCrossMode'
            );
        }
        // verify the required parameter 'inline_object' is set
        if ($inline_object === null || (is_array($inline_object) && count($inline_object) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object when calling updateDualCompPositionCrossMode'
            );
        }

        $resourcePath = '/futures/{settle}/dual_comp/positions/cross_mode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inline_object)) {
            $_tempBody = $inline_object;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePositionRiskLimit
     *
     * Update position risk limit.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position
     */
    public function updatePositionRiskLimit($settle, $contract, $risk_limit)
    {
        list($response) = $this->updatePositionRiskLimitWithHttpInfo($settle, $contract, $risk_limit);
        return $response;
    }

    /**
     * Operation updatePositionRiskLimitWithHttpInfo
     *
     * Update position risk limit.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePositionRiskLimitWithHttpInfo($settle, $contract, $risk_limit)
    {
        $request = $this->updatePositionRiskLimitRequest($settle, $contract, $risk_limit);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updatePositionRiskLimitAsync
     *
     * Update position risk limit.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionRiskLimitAsync($settle, $contract, $risk_limit)
    {
        return $this->updatePositionRiskLimitAsyncWithHttpInfo($settle, $contract, $risk_limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePositionRiskLimitAsyncWithHttpInfo
     *
     * Update position risk limit.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePositionRiskLimitAsyncWithHttpInfo($settle, $contract, $risk_limit)
    {
        $returnType = '\GateApi\Model\Position';
        $request = $this->updatePositionRiskLimitRequest($settle, $contract, $risk_limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePositionRiskLimit'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePositionRiskLimitRequest($settle, $contract, $risk_limit)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updatePositionRiskLimit'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling updatePositionRiskLimit'
            );
        }
        // verify the required parameter 'risk_limit' is set
        if ($risk_limit === null || (is_array($risk_limit) && count($risk_limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $risk_limit when calling updatePositionRiskLimit'
            );
        }

        $resourcePath = '/futures/{settle}/positions/{contract}/risk_limit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($risk_limit !== null) {
            if('form' === 'form' && is_array($risk_limit)) {
                foreach($risk_limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['risk_limit'] = $risk_limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setDualMode
     *
     * Enable or disable dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $dual_mode Whether to enable dual mode. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesAccount
     */
    public function setDualMode($settle, $dual_mode)
    {
        list($response) = $this->setDualModeWithHttpInfo($settle, $dual_mode);
        return $response;
    }

    /**
     * Operation setDualModeWithHttpInfo
     *
     * Enable or disable dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $dual_mode Whether to enable dual mode. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function setDualModeWithHttpInfo($settle, $dual_mode)
    {
        $request = $this->setDualModeRequest($settle, $dual_mode);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesAccount';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation setDualModeAsync
     *
     * Enable or disable dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $dual_mode Whether to enable dual mode. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDualModeAsync($settle, $dual_mode)
    {
        return $this->setDualModeAsyncWithHttpInfo($settle, $dual_mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setDualModeAsyncWithHttpInfo
     *
     * Enable or disable dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $dual_mode Whether to enable dual mode. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setDualModeAsyncWithHttpInfo($settle, $dual_mode)
    {
        $returnType = '\GateApi\Model\FuturesAccount';
        $request = $this->setDualModeRequest($settle, $dual_mode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setDualMode'
     *
     * @param  string $settle Settle currency. (required)
     * @param  bool $dual_mode Whether to enable dual mode. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setDualModeRequest($settle, $dual_mode)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling setDualMode'
            );
        }
        // verify the required parameter 'dual_mode' is set
        if ($dual_mode === null || (is_array($dual_mode) && count($dual_mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dual_mode when calling setDualMode'
            );
        }

        $resourcePath = '/futures/{settle}/dual_mode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dual_mode !== null) {
            if('form' === 'form' && is_array($dual_mode)) {
                foreach($dual_mode as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dual_mode'] = $dual_mode;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDualModePosition
     *
     * Retrieve position detail in dual mode.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position[]
     */
    public function getDualModePosition($associative_array)
    {
        list($response) = $this->getDualModePositionWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getDualModePositionWithHttpInfo
     *
     * Retrieve position detail in dual mode.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDualModePositionWithHttpInfo($associative_array)
    {
        $request = $this->getDualModePositionRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getDualModePositionAsync
     *
     * Retrieve position detail in dual mode.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDualModePositionAsync($associative_array)
    {
        return $this->getDualModePositionAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDualModePositionAsyncWithHttpInfo
     *
     * Retrieve position detail in dual mode.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDualModePositionAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\Position[]';
        $request = $this->getDualModePositionRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDualModePosition'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDualModePositionRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getDualModePosition'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling getDualModePosition'
            );
        }

        $resourcePath = '/futures/{settle}/dual_comp/positions/{contract}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDualModePositionMargin
     *
     * Update position margin in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     * @param  string $dual_side Long or short position. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position[]
     */
    public function updateDualModePositionMargin($settle, $contract, $change, $dual_side)
    {
        list($response) = $this->updateDualModePositionMarginWithHttpInfo($settle, $contract, $change, $dual_side);
        return $response;
    }

    /**
     * Operation updateDualModePositionMarginWithHttpInfo
     *
     * Update position margin in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     * @param  string $dual_side Long or short position. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDualModePositionMarginWithHttpInfo($settle, $contract, $change, $dual_side)
    {
        $request = $this->updateDualModePositionMarginRequest($settle, $contract, $change, $dual_side);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateDualModePositionMarginAsync
     *
     * Update position margin in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     * @param  string $dual_side Long or short position. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualModePositionMarginAsync($settle, $contract, $change, $dual_side)
    {
        return $this->updateDualModePositionMarginAsyncWithHttpInfo($settle, $contract, $change, $dual_side)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDualModePositionMarginAsyncWithHttpInfo
     *
     * Update position margin in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     * @param  string $dual_side Long or short position. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualModePositionMarginAsyncWithHttpInfo($settle, $contract, $change, $dual_side)
    {
        $returnType = '\GateApi\Model\Position[]';
        $request = $this->updateDualModePositionMarginRequest($settle, $contract, $change, $dual_side);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDualModePositionMargin'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $change Margin change amount, positive number increases, negative number. (required)
     * @param  string $dual_side Long or short position. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDualModePositionMarginRequest($settle, $contract, $change, $dual_side)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updateDualModePositionMargin'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling updateDualModePositionMargin'
            );
        }
        // verify the required parameter 'change' is set
        if ($change === null || (is_array($change) && count($change) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change when calling updateDualModePositionMargin'
            );
        }
        // verify the required parameter 'dual_side' is set
        if ($dual_side === null || (is_array($dual_side) && count($dual_side) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dual_side when calling updateDualModePositionMargin'
            );
        }

        $resourcePath = '/futures/{settle}/dual_comp/positions/{contract}/margin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($change !== null) {
            if('form' === 'form' && is_array($change)) {
                foreach($change as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['change'] = $change;
            }
        }

        // query params
        if ($dual_side !== null) {
            if('form' === 'form' && is_array($dual_side)) {
                foreach($dual_side as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dual_side'] = $dual_side;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDualModePositionLeverage
     *
     * Update position leverage in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position[]
     */
    public function updateDualModePositionLeverage($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        list($response) = $this->updateDualModePositionLeverageWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit);
        return $response;
    }

    /**
     * Operation updateDualModePositionLeverageWithHttpInfo
     *
     * Update position leverage in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDualModePositionLeverageWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        $request = $this->updateDualModePositionLeverageRequest($settle, $contract, $leverage, $cross_leverage_limit);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateDualModePositionLeverageAsync
     *
     * Update position leverage in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualModePositionLeverageAsync($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        return $this->updateDualModePositionLeverageAsyncWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDualModePositionLeverageAsyncWithHttpInfo
     *
     * Update position leverage in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualModePositionLeverageAsyncWithHttpInfo($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        $returnType = '\GateApi\Model\Position[]';
        $request = $this->updateDualModePositionLeverageRequest($settle, $contract, $leverage, $cross_leverage_limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDualModePositionLeverage'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $leverage New position leverage. (required)
     * @param  string $cross_leverage_limit Cross margin leverage(valid only when &#x60;leverage&#x60; is 0). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDualModePositionLeverageRequest($settle, $contract, $leverage, $cross_leverage_limit = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updateDualModePositionLeverage'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling updateDualModePositionLeverage'
            );
        }
        // verify the required parameter 'leverage' is set
        if ($leverage === null || (is_array($leverage) && count($leverage) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $leverage when calling updateDualModePositionLeverage'
            );
        }

        $resourcePath = '/futures/{settle}/dual_comp/positions/{contract}/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($leverage !== null) {
            if('form' === 'form' && is_array($leverage)) {
                foreach($leverage as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['leverage'] = $leverage;
            }
        }

        // query params
        if ($cross_leverage_limit !== null) {
            if('form' === 'form' && is_array($cross_leverage_limit)) {
                foreach($cross_leverage_limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cross_leverage_limit'] = $cross_leverage_limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDualModePositionRiskLimit
     *
     * Update position risk limit in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Position[]
     */
    public function updateDualModePositionRiskLimit($settle, $contract, $risk_limit)
    {
        list($response) = $this->updateDualModePositionRiskLimitWithHttpInfo($settle, $contract, $risk_limit);
        return $response;
    }

    /**
     * Operation updateDualModePositionRiskLimitWithHttpInfo
     *
     * Update position risk limit in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Position[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDualModePositionRiskLimitWithHttpInfo($settle, $contract, $risk_limit)
    {
        $request = $this->updateDualModePositionRiskLimitRequest($settle, $contract, $risk_limit);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Position[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation updateDualModePositionRiskLimitAsync
     *
     * Update position risk limit in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualModePositionRiskLimitAsync($settle, $contract, $risk_limit)
    {
        return $this->updateDualModePositionRiskLimitAsyncWithHttpInfo($settle, $contract, $risk_limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDualModePositionRiskLimitAsyncWithHttpInfo
     *
     * Update position risk limit in dual mode.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDualModePositionRiskLimitAsyncWithHttpInfo($settle, $contract, $risk_limit)
    {
        $returnType = '\GateApi\Model\Position[]';
        $request = $this->updateDualModePositionRiskLimitRequest($settle, $contract, $risk_limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDualModePositionRiskLimit'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $risk_limit New Risk Limit Value. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDualModePositionRiskLimitRequest($settle, $contract, $risk_limit)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling updateDualModePositionRiskLimit'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling updateDualModePositionRiskLimit'
            );
        }
        // verify the required parameter 'risk_limit' is set
        if ($risk_limit === null || (is_array($risk_limit) && count($risk_limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $risk_limit when calling updateDualModePositionRiskLimit'
            );
        }

        $resourcePath = '/futures/{settle}/dual_comp/positions/{contract}/risk_limit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($risk_limit !== null) {
            if('form' === 'form' && is_array($risk_limit)) {
                foreach($risk_limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['risk_limit'] = $risk_limit;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($contract !== null) {
            $resourcePath = str_replace(
                '{' . 'contract' . '}',
                ObjectSerializer::toPathValue($contract),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFuturesOrders
     *
     * List futures orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the currency name to query in batches, and support up to 100 pass parameters at a time. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder[]
     */
    public function listFuturesOrders($associative_array)
    {
        list($response) = $this->listFuturesOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listFuturesOrdersWithHttpInfo
     *
     * List futures orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the currency name to query in batches, and support up to 100 pass parameters at a time. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listFuturesOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listFuturesOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listFuturesOrdersAsync
     *
     * List futures orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the currency name to query in batches, and support up to 100 pass parameters at a time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesOrdersAsync($associative_array)
    {
        return $this->listFuturesOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFuturesOrdersAsyncWithHttpInfo
     *
     * List futures orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the currency name to query in batches, and support up to 100 pass parameters at a time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFuturesOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesOrder[]';
        $request = $this->listFuturesOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFuturesOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the currency name to query in batches, and support up to 100 pass parameters at a time. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFuturesOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $status = array_key_exists('status', $associative_array) ? $associative_array['status'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $last_id = array_key_exists('last_id', $associative_array) ? $associative_array['last_id'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listFuturesOrders'
            );
        }
        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling listFuturesOrders'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesOrders, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listFuturesOrders, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listFuturesOrders, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($last_id !== null) {
            if('form' === 'form' && is_array($last_id)) {
                foreach($last_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['last_id'] = $last_id;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFuturesOrder
     *
     * Create a futures order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder $futures_order futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder
     */
    public function createFuturesOrder($settle, $futures_order, $x_gate_exptime = null)
    {
        list($response) = $this->createFuturesOrderWithHttpInfo($settle, $futures_order, $x_gate_exptime);
        return $response;
    }

    /**
     * Operation createFuturesOrderWithHttpInfo
     *
     * Create a futures order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFuturesOrderWithHttpInfo($settle, $futures_order, $x_gate_exptime = null)
    {
        $request = $this->createFuturesOrderRequest($settle, $futures_order, $x_gate_exptime);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createFuturesOrderAsync
     *
     * Create a futures order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFuturesOrderAsync($settle, $futures_order, $x_gate_exptime = null)
    {
        return $this->createFuturesOrderAsyncWithHttpInfo($settle, $futures_order, $x_gate_exptime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFuturesOrderAsyncWithHttpInfo
     *
     * Create a futures order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFuturesOrderAsyncWithHttpInfo($settle, $futures_order, $x_gate_exptime = null)
    {
        $returnType = '\GateApi\Model\FuturesOrder';
        $request = $this->createFuturesOrderRequest($settle, $futures_order, $x_gate_exptime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFuturesOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFuturesOrderRequest($settle, $futures_order, $x_gate_exptime = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling createFuturesOrder'
            );
        }
        // verify the required parameter 'futures_order' is set
        if ($futures_order === null || (is_array($futures_order) && count($futures_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $futures_order when calling createFuturesOrder'
            );
        }

        $resourcePath = '/futures/{settle}/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($futures_order)) {
            $_tempBody = $futures_order;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelFuturesOrders
     *
     * Cancel all `open` orders matched.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param  string $side Specify all buy orders or all sell orders, both are included if not specified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell orders (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder[]
     */
    public function cancelFuturesOrders($settle, $contract, $x_gate_exptime = null, $side = null)
    {
        list($response) = $this->cancelFuturesOrdersWithHttpInfo($settle, $contract, $x_gate_exptime, $side);
        return $response;
    }

    /**
     * Operation cancelFuturesOrdersWithHttpInfo
     *
     * Cancel all `open` orders matched.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param  string $side Specify all buy orders or all sell orders, both are included if not specified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell orders (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelFuturesOrdersWithHttpInfo($settle, $contract, $x_gate_exptime = null, $side = null)
    {
        $request = $this->cancelFuturesOrdersRequest($settle, $contract, $x_gate_exptime, $side);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelFuturesOrdersAsync
     *
     * Cancel all `open` orders matched.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param  string $side Specify all buy orders or all sell orders, both are included if not specified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelFuturesOrdersAsync($settle, $contract, $x_gate_exptime = null, $side = null)
    {
        return $this->cancelFuturesOrdersAsyncWithHttpInfo($settle, $contract, $x_gate_exptime, $side)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelFuturesOrdersAsyncWithHttpInfo
     *
     * Cancel all `open` orders matched.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param  string $side Specify all buy orders or all sell orders, both are included if not specified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelFuturesOrdersAsyncWithHttpInfo($settle, $contract, $x_gate_exptime = null, $side = null)
    {
        $returnType = '\GateApi\Model\FuturesOrder[]';
        $request = $this->cancelFuturesOrdersRequest($settle, $contract, $x_gate_exptime, $side);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelFuturesOrders'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     * @param  string $side Specify all buy orders or all sell orders, both are included if not specified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell ordersspecified. Set to bid, set to ask to cancel all sell orders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelFuturesOrdersRequest($settle, $contract, $x_gate_exptime = null, $side = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling cancelFuturesOrders'
            );
        }
        // verify the required parameter 'contract' is set
        if ($contract === null || (is_array($contract) && count($contract) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract when calling cancelFuturesOrders'
            );
        }

        $resourcePath = '/futures/{settle}/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($side !== null) {
            if('form' === 'form' && is_array($side)) {
                foreach($side as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['side'] = $side;
            }
        }

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrdersWithTimeRange
     *
     * List Futures Orders By Time Range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder[]
     */
    public function getOrdersWithTimeRange($associative_array)
    {
        list($response) = $this->getOrdersWithTimeRangeWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getOrdersWithTimeRangeWithHttpInfo
     *
     * List Futures Orders By Time Range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrdersWithTimeRangeWithHttpInfo($associative_array)
    {
        $request = $this->getOrdersWithTimeRangeRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getOrdersWithTimeRangeAsync
     *
     * List Futures Orders By Time Range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrdersWithTimeRangeAsync($associative_array)
    {
        return $this->getOrdersWithTimeRangeAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrdersWithTimeRangeAsyncWithHttpInfo
     *
     * List Futures Orders By Time Range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrdersWithTimeRangeAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesOrder[]';
        $request = $this->getOrdersWithTimeRangeRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrdersWithTimeRange'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrdersWithTimeRangeRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getOrdersWithTimeRange'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.getOrdersWithTimeRange, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.getOrdersWithTimeRange, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.getOrdersWithTimeRange, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/orders_timerange';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBatchFuturesOrder
     *
     * Create a batch of futures orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder[] $futures_order futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\BatchFuturesOrder[]
     */
    public function createBatchFuturesOrder($settle, $futures_order, $x_gate_exptime = null)
    {
        list($response) = $this->createBatchFuturesOrderWithHttpInfo($settle, $futures_order, $x_gate_exptime);
        return $response;
    }

    /**
     * Operation createBatchFuturesOrderWithHttpInfo
     *
     * Create a batch of futures orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder[] $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\BatchFuturesOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchFuturesOrderWithHttpInfo($settle, $futures_order, $x_gate_exptime = null)
    {
        $request = $this->createBatchFuturesOrderRequest($settle, $futures_order, $x_gate_exptime);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\BatchFuturesOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createBatchFuturesOrderAsync
     *
     * Create a batch of futures orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder[] $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchFuturesOrderAsync($settle, $futures_order, $x_gate_exptime = null)
    {
        return $this->createBatchFuturesOrderAsyncWithHttpInfo($settle, $futures_order, $x_gate_exptime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBatchFuturesOrderAsyncWithHttpInfo
     *
     * Create a batch of futures orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder[] $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchFuturesOrderAsyncWithHttpInfo($settle, $futures_order, $x_gate_exptime = null)
    {
        $returnType = '\GateApi\Model\BatchFuturesOrder[]';
        $request = $this->createBatchFuturesOrderRequest($settle, $futures_order, $x_gate_exptime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBatchFuturesOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesOrder[] $futures_order (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createBatchFuturesOrderRequest($settle, $futures_order, $x_gate_exptime = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling createBatchFuturesOrder'
            );
        }
        // verify the required parameter 'futures_order' is set
        if ($futures_order === null || (is_array($futures_order) && count($futures_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $futures_order when calling createBatchFuturesOrder'
            );
        }

        $resourcePath = '/futures/{settle}/batch_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($futures_order)) {
            $_tempBody = $futures_order;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFuturesOrder
     *
     * Get a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder
     */
    public function getFuturesOrder($settle, $order_id)
    {
        list($response) = $this->getFuturesOrderWithHttpInfo($settle, $order_id);
        return $response;
    }

    /**
     * Operation getFuturesOrderWithHttpInfo
     *
     * Get a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFuturesOrderWithHttpInfo($settle, $order_id)
    {
        $request = $this->getFuturesOrderRequest($settle, $order_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getFuturesOrderAsync
     *
     * Get a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesOrderAsync($settle, $order_id)
    {
        return $this->getFuturesOrderAsyncWithHttpInfo($settle, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFuturesOrderAsyncWithHttpInfo
     *
     * Get a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesOrderAsyncWithHttpInfo($settle, $order_id)
    {
        $returnType = '\GateApi\Model\FuturesOrder';
        $request = $this->getFuturesOrderRequest($settle, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFuturesOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFuturesOrderRequest($settle, $order_id)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getFuturesOrder'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getFuturesOrder'
            );
        }

        $resourcePath = '/futures/{settle}/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation amendFuturesOrder
     *
     * Amend an order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  \GateApi\Model\FuturesOrderAmendment $futures_order_amendment futures_order_amendment (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder
     */
    public function amendFuturesOrder($settle, $order_id, $futures_order_amendment, $x_gate_exptime = null)
    {
        list($response) = $this->amendFuturesOrderWithHttpInfo($settle, $order_id, $futures_order_amendment, $x_gate_exptime);
        return $response;
    }

    /**
     * Operation amendFuturesOrderWithHttpInfo
     *
     * Amend an order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  \GateApi\Model\FuturesOrderAmendment $futures_order_amendment (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function amendFuturesOrderWithHttpInfo($settle, $order_id, $futures_order_amendment, $x_gate_exptime = null)
    {
        $request = $this->amendFuturesOrderRequest($settle, $order_id, $futures_order_amendment, $x_gate_exptime);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation amendFuturesOrderAsync
     *
     * Amend an order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  \GateApi\Model\FuturesOrderAmendment $futures_order_amendment (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function amendFuturesOrderAsync($settle, $order_id, $futures_order_amendment, $x_gate_exptime = null)
    {
        return $this->amendFuturesOrderAsyncWithHttpInfo($settle, $order_id, $futures_order_amendment, $x_gate_exptime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation amendFuturesOrderAsyncWithHttpInfo
     *
     * Amend an order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  \GateApi\Model\FuturesOrderAmendment $futures_order_amendment (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function amendFuturesOrderAsyncWithHttpInfo($settle, $order_id, $futures_order_amendment, $x_gate_exptime = null)
    {
        $returnType = '\GateApi\Model\FuturesOrder';
        $request = $this->amendFuturesOrderRequest($settle, $order_id, $futures_order_amendment, $x_gate_exptime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'amendFuturesOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  \GateApi\Model\FuturesOrderAmendment $futures_order_amendment (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function amendFuturesOrderRequest($settle, $order_id, $futures_order_amendment, $x_gate_exptime = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling amendFuturesOrder'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling amendFuturesOrder'
            );
        }
        // verify the required parameter 'futures_order_amendment' is set
        if ($futures_order_amendment === null || (is_array($futures_order_amendment) && count($futures_order_amendment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $futures_order_amendment when calling amendFuturesOrder'
            );
        }

        $resourcePath = '/futures/{settle}/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($futures_order_amendment)) {
            $_tempBody = $futures_order_amendment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('PUT', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelFuturesOrder
     *
     * Cancel a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesOrder
     */
    public function cancelFuturesOrder($settle, $order_id, $x_gate_exptime = null)
    {
        list($response) = $this->cancelFuturesOrderWithHttpInfo($settle, $order_id, $x_gate_exptime);
        return $response;
    }

    /**
     * Operation cancelFuturesOrderWithHttpInfo
     *
     * Cancel a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelFuturesOrderWithHttpInfo($settle, $order_id, $x_gate_exptime = null)
    {
        $request = $this->cancelFuturesOrderRequest($settle, $order_id, $x_gate_exptime);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelFuturesOrderAsync
     *
     * Cancel a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelFuturesOrderAsync($settle, $order_id, $x_gate_exptime = null)
    {
        return $this->cancelFuturesOrderAsyncWithHttpInfo($settle, $order_id, $x_gate_exptime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelFuturesOrderAsyncWithHttpInfo
     *
     * Cancel a single order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelFuturesOrderAsyncWithHttpInfo($settle, $order_id, $x_gate_exptime = null)
    {
        $returnType = '\GateApi\Model\FuturesOrder';
        $request = $this->cancelFuturesOrderRequest($settle, $order_id, $x_gate_exptime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelFuturesOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted. (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelFuturesOrderRequest($settle, $order_id, $x_gate_exptime = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling cancelFuturesOrder'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling cancelFuturesOrder'
            );
        }

        $resourcePath = '/futures/{settle}/orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyTrades
     *
     * List personal trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $order Futures order ID, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\MyFuturesTrade[]
     */
    public function getMyTrades($associative_array)
    {
        list($response) = $this->getMyTradesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getMyTradesWithHttpInfo
     *
     * List personal trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $order Futures order ID, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\MyFuturesTrade[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyTradesWithHttpInfo($associative_array)
    {
        $request = $this->getMyTradesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\MyFuturesTrade[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getMyTradesAsync
     *
     * List personal trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $order Futures order ID, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyTradesAsync($associative_array)
    {
        return $this->getMyTradesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyTradesAsyncWithHttpInfo
     *
     * List personal trading history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $order Futures order ID, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyTradesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\MyFuturesTrade[]';
        $request = $this->getMyTradesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyTrades'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $order Futures order ID, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $last_id Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyTradesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $order = array_key_exists('order', $associative_array) ? $associative_array['order'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $last_id = array_key_exists('last_id', $associative_array) ? $associative_array['last_id'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getMyTrades'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.getMyTrades, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.getMyTrades, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.getMyTrades, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/my_trades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($order !== null) {
            if('form' === 'form' && is_array($order)) {
                foreach($order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['order'] = $order;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($last_id !== null) {
            if('form' === 'form' && is_array($last_id)) {
                foreach($last_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['last_id'] = $last_id;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyTradesWithTimeRange
     *
     * List personal trading history by time range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $role Query role, maker or taker. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\MyFuturesTradeTimeRange[]
     */
    public function getMyTradesWithTimeRange($associative_array)
    {
        list($response) = $this->getMyTradesWithTimeRangeWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getMyTradesWithTimeRangeWithHttpInfo
     *
     * List personal trading history by time range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $role Query role, maker or taker. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\MyFuturesTradeTimeRange[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyTradesWithTimeRangeWithHttpInfo($associative_array)
    {
        $request = $this->getMyTradesWithTimeRangeRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\MyFuturesTradeTimeRange[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getMyTradesWithTimeRangeAsync
     *
     * List personal trading history by time range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $role Query role, maker or taker. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyTradesWithTimeRangeAsync($associative_array)
    {
        return $this->getMyTradesWithTimeRangeAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyTradesWithTimeRangeAsyncWithHttpInfo
     *
     * List personal trading history by time range.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $role Query role, maker or taker. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyTradesWithTimeRangeAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\MyFuturesTradeTimeRange[]';
        $request = $this->getMyTradesWithTimeRangeRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyTradesWithTimeRange'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  string $role Query role, maker or taker. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMyTradesWithTimeRangeRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $role = array_key_exists('role', $associative_array) ? $associative_array['role'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getMyTradesWithTimeRange'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.getMyTradesWithTimeRange, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.getMyTradesWithTimeRange, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.getMyTradesWithTimeRange, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/my_trades_timerange';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($role !== null) {
            if('form' === 'form' && is_array($role)) {
                foreach($role as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['role'] = $role;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPositionClose
     *
     * List position close history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $side Query side. long or shot. (optional)
     * @param  string $pnl Query profit or loss. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\PositionClose[]
     */
    public function listPositionClose($associative_array)
    {
        list($response) = $this->listPositionCloseWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listPositionCloseWithHttpInfo
     *
     * List position close history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $side Query side. long or shot. (optional)
     * @param  string $pnl Query profit or loss. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\PositionClose[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listPositionCloseWithHttpInfo($associative_array)
    {
        $request = $this->listPositionCloseRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\PositionClose[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listPositionCloseAsync
     *
     * List position close history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $side Query side. long or shot. (optional)
     * @param  string $pnl Query profit or loss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPositionCloseAsync($associative_array)
    {
        return $this->listPositionCloseAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPositionCloseAsyncWithHttpInfo
     *
     * List position close history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $side Query side. long or shot. (optional)
     * @param  string $pnl Query profit or loss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPositionCloseAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\PositionClose[]';
        $request = $this->listPositionCloseRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPositionClose'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  string $side Query side. long or shot. (optional)
     * @param  string $pnl Query profit or loss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPositionCloseRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $side = array_key_exists('side', $associative_array) ? $associative_array['side'] : null;
        $pnl = array_key_exists('pnl', $associative_array) ? $associative_array['pnl'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listPositionClose'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listPositionClose, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listPositionClose, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listPositionClose, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/position_close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($side !== null) {
            if('form' === 'form' && is_array($side)) {
                foreach($side as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['side'] = $side;
            }
        }

        // query params
        if ($pnl !== null) {
            if('form' === 'form' && is_array($pnl)) {
                foreach($pnl as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pnl'] = $pnl;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLiquidates
     *
     * List liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify a liquidation timestamp. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesLiquidate[]
     */
    public function listLiquidates($associative_array)
    {
        list($response) = $this->listLiquidatesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listLiquidatesWithHttpInfo
     *
     * List liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify a liquidation timestamp. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesLiquidate[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLiquidatesWithHttpInfo($associative_array)
    {
        $request = $this->listLiquidatesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesLiquidate[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listLiquidatesAsync
     *
     * List liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify a liquidation timestamp. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLiquidatesAsync($associative_array)
    {
        return $this->listLiquidatesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLiquidatesAsyncWithHttpInfo
     *
     * List liquidation history.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify a liquidation timestamp. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLiquidatesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesLiquidate[]';
        $request = $this->listLiquidatesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLiquidates'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify a liquidation timestamp. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLiquidatesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $at = array_key_exists('at', $associative_array) ? $associative_array['at'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listLiquidates'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listLiquidates, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listLiquidates, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listLiquidates, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/liquidates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAutoDeleverages
     *
     * List Auto-Deleveraging History.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify an auto-deleveraging timestamp. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesAutoDeleverage[]
     */
    public function listAutoDeleverages($associative_array)
    {
        list($response) = $this->listAutoDeleveragesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listAutoDeleveragesWithHttpInfo
     *
     * List Auto-Deleveraging History.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify an auto-deleveraging timestamp. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesAutoDeleverage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listAutoDeleveragesWithHttpInfo($associative_array)
    {
        $request = $this->listAutoDeleveragesRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesAutoDeleverage[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listAutoDeleveragesAsync
     *
     * List Auto-Deleveraging History.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify an auto-deleveraging timestamp. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAutoDeleveragesAsync($associative_array)
    {
        return $this->listAutoDeleveragesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAutoDeleveragesAsyncWithHttpInfo
     *
     * List Auto-Deleveraging History.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify an auto-deleveraging timestamp. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAutoDeleveragesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesAutoDeleverage[]';
        $request = $this->listAutoDeleveragesRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAutoDeleverages'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $at Specify an auto-deleveraging timestamp. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAutoDeleveragesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $at = array_key_exists('at', $associative_array) ? $associative_array['at'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listAutoDeleverages'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listAutoDeleverages, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listAutoDeleverages, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listAutoDeleverages, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/auto_deleverages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation countdownCancelAllFutures
     *
     * Countdown cancel orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\CountdownCancelAllFuturesTask $countdown_cancel_all_futures_task countdown_cancel_all_futures_task (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\TriggerTime
     */
    public function countdownCancelAllFutures($settle, $countdown_cancel_all_futures_task)
    {
        list($response) = $this->countdownCancelAllFuturesWithHttpInfo($settle, $countdown_cancel_all_futures_task);
        return $response;
    }

    /**
     * Operation countdownCancelAllFuturesWithHttpInfo
     *
     * Countdown cancel orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\CountdownCancelAllFuturesTask $countdown_cancel_all_futures_task (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\TriggerTime, HTTP status code, HTTP response headers (array of strings)
     */
    public function countdownCancelAllFuturesWithHttpInfo($settle, $countdown_cancel_all_futures_task)
    {
        $request = $this->countdownCancelAllFuturesRequest($settle, $countdown_cancel_all_futures_task);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\TriggerTime';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation countdownCancelAllFuturesAsync
     *
     * Countdown cancel orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\CountdownCancelAllFuturesTask $countdown_cancel_all_futures_task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countdownCancelAllFuturesAsync($settle, $countdown_cancel_all_futures_task)
    {
        return $this->countdownCancelAllFuturesAsyncWithHttpInfo($settle, $countdown_cancel_all_futures_task)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countdownCancelAllFuturesAsyncWithHttpInfo
     *
     * Countdown cancel orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\CountdownCancelAllFuturesTask $countdown_cancel_all_futures_task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countdownCancelAllFuturesAsyncWithHttpInfo($settle, $countdown_cancel_all_futures_task)
    {
        $returnType = '\GateApi\Model\TriggerTime';
        $request = $this->countdownCancelAllFuturesRequest($settle, $countdown_cancel_all_futures_task);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'countdownCancelAllFutures'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\CountdownCancelAllFuturesTask $countdown_cancel_all_futures_task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function countdownCancelAllFuturesRequest($settle, $countdown_cancel_all_futures_task)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling countdownCancelAllFutures'
            );
        }
        // verify the required parameter 'countdown_cancel_all_futures_task' is set
        if ($countdown_cancel_all_futures_task === null || (is_array($countdown_cancel_all_futures_task) && count($countdown_cancel_all_futures_task) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $countdown_cancel_all_futures_task when calling countdownCancelAllFutures'
            );
        }

        $resourcePath = '/futures/{settle}/countdown_cancel_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($countdown_cancel_all_futures_task)) {
            $_tempBody = $countdown_cancel_all_futures_task;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFuturesFee
     *
     * Query user trading fee rates.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\GateApi\Model\FuturesFee]
     */
    public function getFuturesFee($associative_array)
    {
        list($response) = $this->getFuturesFeeWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getFuturesFeeWithHttpInfo
     *
     * Query user trading fee rates.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\GateApi\Model\FuturesFee], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFuturesFeeWithHttpInfo($associative_array)
    {
        $request = $this->getFuturesFeeRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = 'map[string,\GateApi\Model\FuturesFee]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getFuturesFeeAsync
     *
     * Query user trading fee rates.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesFeeAsync($associative_array)
    {
        return $this->getFuturesFeeAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFuturesFeeAsyncWithHttpInfo
     *
     * Query user trading fee rates.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesFeeAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'map[string,\GateApi\Model\FuturesFee]';
        $request = $this->getFuturesFeeRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFuturesFee'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFuturesFeeRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getFuturesFee'
            );
        }

        $resourcePath = '/futures/{settle}/fee';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelBatchFutureOrders
     *
     * Cancel a batch of orders with an ID list.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string[] $request_body request_body (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FutureCancelOrderResult[]
     */
    public function cancelBatchFutureOrders($settle, $request_body, $x_gate_exptime = null)
    {
        list($response) = $this->cancelBatchFutureOrdersWithHttpInfo($settle, $request_body, $x_gate_exptime);
        return $response;
    }

    /**
     * Operation cancelBatchFutureOrdersWithHttpInfo
     *
     * Cancel a batch of orders with an ID list.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string[] $request_body (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FutureCancelOrderResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelBatchFutureOrdersWithHttpInfo($settle, $request_body, $x_gate_exptime = null)
    {
        $request = $this->cancelBatchFutureOrdersRequest($settle, $request_body, $x_gate_exptime);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FutureCancelOrderResult[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelBatchFutureOrdersAsync
     *
     * Cancel a batch of orders with an ID list.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string[] $request_body (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelBatchFutureOrdersAsync($settle, $request_body, $x_gate_exptime = null)
    {
        return $this->cancelBatchFutureOrdersAsyncWithHttpInfo($settle, $request_body, $x_gate_exptime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelBatchFutureOrdersAsyncWithHttpInfo
     *
     * Cancel a batch of orders with an ID list.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string[] $request_body (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelBatchFutureOrdersAsyncWithHttpInfo($settle, $request_body, $x_gate_exptime = null)
    {
        $returnType = '\GateApi\Model\FutureCancelOrderResult[]';
        $request = $this->cancelBatchFutureOrdersRequest($settle, $request_body, $x_gate_exptime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelBatchFutureOrders'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string[] $request_body (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelBatchFutureOrdersRequest($settle, $request_body, $x_gate_exptime = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling cancelBatchFutureOrders'
            );
        }
        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling cancelBatchFutureOrders'
            );
        }

        $resourcePath = '/futures/{settle}/batch_cancel_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($request_body)) {
            $_tempBody = $request_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation amendBatchFutureOrders
     *
     * Batch modify orders with specified IDs.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\BatchAmendOrderReq[] $batch_amend_order_req batch_amend_order_req (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\BatchFuturesOrder[]
     */
    public function amendBatchFutureOrders($settle, $batch_amend_order_req, $x_gate_exptime = null)
    {
        list($response) = $this->amendBatchFutureOrdersWithHttpInfo($settle, $batch_amend_order_req, $x_gate_exptime);
        return $response;
    }

    /**
     * Operation amendBatchFutureOrdersWithHttpInfo
     *
     * Batch modify orders with specified IDs.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\BatchAmendOrderReq[] $batch_amend_order_req (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\BatchFuturesOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function amendBatchFutureOrdersWithHttpInfo($settle, $batch_amend_order_req, $x_gate_exptime = null)
    {
        $request = $this->amendBatchFutureOrdersRequest($settle, $batch_amend_order_req, $x_gate_exptime);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\BatchFuturesOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation amendBatchFutureOrdersAsync
     *
     * Batch modify orders with specified IDs.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\BatchAmendOrderReq[] $batch_amend_order_req (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function amendBatchFutureOrdersAsync($settle, $batch_amend_order_req, $x_gate_exptime = null)
    {
        return $this->amendBatchFutureOrdersAsyncWithHttpInfo($settle, $batch_amend_order_req, $x_gate_exptime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation amendBatchFutureOrdersAsyncWithHttpInfo
     *
     * Batch modify orders with specified IDs.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\BatchAmendOrderReq[] $batch_amend_order_req (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function amendBatchFutureOrdersAsyncWithHttpInfo($settle, $batch_amend_order_req, $x_gate_exptime = null)
    {
        $returnType = '\GateApi\Model\BatchFuturesOrder[]';
        $request = $this->amendBatchFutureOrdersRequest($settle, $batch_amend_order_req, $x_gate_exptime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'amendBatchFutureOrders'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\BatchAmendOrderReq[] $batch_amend_order_req (required)
     * @param  string $x_gate_exptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function amendBatchFutureOrdersRequest($settle, $batch_amend_order_req, $x_gate_exptime = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling amendBatchFutureOrders'
            );
        }
        // verify the required parameter 'batch_amend_order_req' is set
        if ($batch_amend_order_req === null || (is_array($batch_amend_order_req) && count($batch_amend_order_req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_amend_order_req when calling amendBatchFutureOrders'
            );
        }

        $resourcePath = '/futures/{settle}/batch_amend_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_gate_exptime !== null) {
            $headerParams['x-gate-exptime'] = ObjectSerializer::toHeaderValue($x_gate_exptime);
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($batch_amend_order_req)) {
            $_tempBody = $batch_amend_order_req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFuturesRiskLimitTable
     *
     * Query risk limit table by table_id.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $table_id Risk limit table ID. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesRiskLimitTier[]
     */
    public function getFuturesRiskLimitTable($settle, $table_id)
    {
        list($response) = $this->getFuturesRiskLimitTableWithHttpInfo($settle, $table_id);
        return $response;
    }

    /**
     * Operation getFuturesRiskLimitTableWithHttpInfo
     *
     * Query risk limit table by table_id.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $table_id Risk limit table ID. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesRiskLimitTier[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFuturesRiskLimitTableWithHttpInfo($settle, $table_id)
    {
        $request = $this->getFuturesRiskLimitTableRequest($settle, $table_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesRiskLimitTier[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getFuturesRiskLimitTableAsync
     *
     * Query risk limit table by table_id.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $table_id Risk limit table ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesRiskLimitTableAsync($settle, $table_id)
    {
        return $this->getFuturesRiskLimitTableAsyncWithHttpInfo($settle, $table_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFuturesRiskLimitTableAsyncWithHttpInfo
     *
     * Query risk limit table by table_id.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $table_id Risk limit table ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFuturesRiskLimitTableAsyncWithHttpInfo($settle, $table_id)
    {
        $returnType = '\GateApi\Model\FuturesRiskLimitTier[]';
        $request = $this->getFuturesRiskLimitTableRequest($settle, $table_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFuturesRiskLimitTable'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $table_id Risk limit table ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFuturesRiskLimitTableRequest($settle, $table_id)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getFuturesRiskLimitTable'
            );
        }
        // verify the required parameter 'table_id' is set
        if ($table_id === null || (is_array($table_id) && count($table_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table_id when calling getFuturesRiskLimitTable'
            );
        }

        $resourcePath = '/futures/{settle}/risk_limit_table';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($table_id !== null) {
            if('form' === 'form' && is_array($table_id)) {
                foreach($table_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['table_id'] = $table_id;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPriceTriggeredOrders
     *
     * List All Price-triggered Orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesPriceTriggeredOrder[]
     */
    public function listPriceTriggeredOrders($associative_array)
    {
        list($response) = $this->listPriceTriggeredOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listPriceTriggeredOrdersWithHttpInfo
     *
     * List All Price-triggered Orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesPriceTriggeredOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listPriceTriggeredOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listPriceTriggeredOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listPriceTriggeredOrdersAsync
     *
     * List All Price-triggered Orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPriceTriggeredOrdersAsync($associative_array)
    {
        return $this->listPriceTriggeredOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPriceTriggeredOrdersAsyncWithHttpInfo
     *
     * List All Price-triggered Orders.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPriceTriggeredOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder[]';
        $request = $this->listPriceTriggeredOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPriceTriggeredOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $status Only list the orders with this status. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     * @param  int $offset List offset, starting from 0. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPriceTriggeredOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $settle = array_key_exists('settle', $associative_array) ? $associative_array['settle'] : null;
        $status = array_key_exists('status', $associative_array) ? $associative_array['status'] : null;
        $contract = array_key_exists('contract', $associative_array) ? $associative_array['contract'] : null;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : 0;

        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling listPriceTriggeredOrders'
            );
        }
        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling listPriceTriggeredOrders'
            );
        }
        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listPriceTriggeredOrders, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling FuturesApi.listPriceTriggeredOrders, must be bigger than or equal to 1.');
        }

        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling FuturesApi.listPriceTriggeredOrders, must be bigger than or equal to 0.');
        }


        $resourcePath = '/futures/{settle}/price_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPriceTriggeredOrder
     *
     * Create a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPriceTriggeredOrder $futures_price_triggered_order futures_price_triggered_order (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\TriggerOrderResponse
     */
    public function createPriceTriggeredOrder($settle, $futures_price_triggered_order)
    {
        list($response) = $this->createPriceTriggeredOrderWithHttpInfo($settle, $futures_price_triggered_order);
        return $response;
    }

    /**
     * Operation createPriceTriggeredOrderWithHttpInfo
     *
     * Create a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPriceTriggeredOrder $futures_price_triggered_order (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\TriggerOrderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPriceTriggeredOrderWithHttpInfo($settle, $futures_price_triggered_order)
    {
        $request = $this->createPriceTriggeredOrderRequest($settle, $futures_price_triggered_order);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\TriggerOrderResponse';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation createPriceTriggeredOrderAsync
     *
     * Create a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPriceTriggeredOrder $futures_price_triggered_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPriceTriggeredOrderAsync($settle, $futures_price_triggered_order)
    {
        return $this->createPriceTriggeredOrderAsyncWithHttpInfo($settle, $futures_price_triggered_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPriceTriggeredOrderAsyncWithHttpInfo
     *
     * Create a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPriceTriggeredOrder $futures_price_triggered_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPriceTriggeredOrderAsyncWithHttpInfo($settle, $futures_price_triggered_order)
    {
        $returnType = '\GateApi\Model\TriggerOrderResponse';
        $request = $this->createPriceTriggeredOrderRequest($settle, $futures_price_triggered_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPriceTriggeredOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  \GateApi\Model\FuturesPriceTriggeredOrder $futures_price_triggered_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPriceTriggeredOrderRequest($settle, $futures_price_triggered_order)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling createPriceTriggeredOrder'
            );
        }
        // verify the required parameter 'futures_price_triggered_order' is set
        if ($futures_price_triggered_order === null || (is_array($futures_price_triggered_order) && count($futures_price_triggered_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $futures_price_triggered_order when calling createPriceTriggeredOrder'
            );
        }

        $resourcePath = '/futures/{settle}/price_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($futures_price_triggered_order)) {
            $_tempBody = $futures_price_triggered_order;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelPriceTriggeredOrderList
     *
     * Cancel All Price-triggered Orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesPriceTriggeredOrder[]
     */
    public function cancelPriceTriggeredOrderList($settle, $contract = null)
    {
        list($response) = $this->cancelPriceTriggeredOrderListWithHttpInfo($settle, $contract);
        return $response;
    }

    /**
     * Operation cancelPriceTriggeredOrderListWithHttpInfo
     *
     * Cancel All Price-triggered Orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesPriceTriggeredOrder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelPriceTriggeredOrderListWithHttpInfo($settle, $contract = null)
    {
        $request = $this->cancelPriceTriggeredOrderListRequest($settle, $contract);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelPriceTriggeredOrderListAsync
     *
     * Cancel All Price-triggered Orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelPriceTriggeredOrderListAsync($settle, $contract = null)
    {
        return $this->cancelPriceTriggeredOrderListAsyncWithHttpInfo($settle, $contract)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelPriceTriggeredOrderListAsyncWithHttpInfo
     *
     * Cancel All Price-triggered Orders.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelPriceTriggeredOrderListAsyncWithHttpInfo($settle, $contract = null)
    {
        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder[]';
        $request = $this->cancelPriceTriggeredOrderListRequest($settle, $contract);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelPriceTriggeredOrderList'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $contract Futures contract, return related data only if specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelPriceTriggeredOrderListRequest($settle, $contract = null)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling cancelPriceTriggeredOrderList'
            );
        }

        $resourcePath = '/futures/{settle}/price_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contract !== null) {
            if('form' === 'form' && is_array($contract)) {
                foreach($contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contract'] = $contract;
            }
        }

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPriceTriggeredOrder
     *
     * Get a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesPriceTriggeredOrder
     */
    public function getPriceTriggeredOrder($settle, $order_id)
    {
        list($response) = $this->getPriceTriggeredOrderWithHttpInfo($settle, $order_id);
        return $response;
    }

    /**
     * Operation getPriceTriggeredOrderWithHttpInfo
     *
     * Get a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesPriceTriggeredOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPriceTriggeredOrderWithHttpInfo($settle, $order_id)
    {
        $request = $this->getPriceTriggeredOrderRequest($settle, $order_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation getPriceTriggeredOrderAsync
     *
     * Get a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceTriggeredOrderAsync($settle, $order_id)
    {
        return $this->getPriceTriggeredOrderAsyncWithHttpInfo($settle, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPriceTriggeredOrderAsyncWithHttpInfo
     *
     * Get a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPriceTriggeredOrderAsyncWithHttpInfo($settle, $order_id)
    {
        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder';
        $request = $this->getPriceTriggeredOrderRequest($settle, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPriceTriggeredOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPriceTriggeredOrderRequest($settle, $order_id)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling getPriceTriggeredOrder'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getPriceTriggeredOrder'
            );
        }

        $resourcePath = '/futures/{settle}/price_orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelPriceTriggeredOrder
     *
     * cancel a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\FuturesPriceTriggeredOrder
     */
    public function cancelPriceTriggeredOrder($settle, $order_id)
    {
        list($response) = $this->cancelPriceTriggeredOrderWithHttpInfo($settle, $order_id);
        return $response;
    }

    /**
     * Operation cancelPriceTriggeredOrderWithHttpInfo
     *
     * cancel a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\FuturesPriceTriggeredOrder, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelPriceTriggeredOrderWithHttpInfo($settle, $order_id)
    {
        $request = $this->cancelPriceTriggeredOrderRequest($settle, $order_id);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation cancelPriceTriggeredOrderAsync
     *
     * cancel a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelPriceTriggeredOrderAsync($settle, $order_id)
    {
        return $this->cancelPriceTriggeredOrderAsyncWithHttpInfo($settle, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelPriceTriggeredOrderAsyncWithHttpInfo
     *
     * cancel a price-triggered order.
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelPriceTriggeredOrderAsyncWithHttpInfo($settle, $order_id)
    {
        $returnType = '\GateApi\Model\FuturesPriceTriggeredOrder';
        $request = $this->cancelPriceTriggeredOrderRequest($settle, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelPriceTriggeredOrder'
     *
     * @param  string $settle Settle currency. (required)
     * @param  string $order_id Retrieve the data of the order with the specified ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelPriceTriggeredOrderRequest($settle, $order_id)
    {
        // verify the required parameter 'settle' is set
        if ($settle === null || (is_array($settle) && count($settle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settle when calling cancelPriceTriggeredOrder'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling cancelPriceTriggeredOrder'
            );
        }

        $resourcePath = '/futures/{settle}/price_orders/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($settle !== null) {
            $resourcePath = str_replace(
                '{' . 'settle' . '}',
                ObjectSerializer::toPathValue($settle),
                $resourcePath
            );
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('DELETE', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
