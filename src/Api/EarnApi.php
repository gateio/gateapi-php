<?php
/**
 * EarnApi
 * PHP version 7
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */

/**
 * Gate API
 *
 * Welcome to Gate API  APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 * Generated by: https://openapi-generator.tech
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace GateApi\Api;

use GateApi\ApiException;
use GateApi\Configuration;
use GateApi\GateApiException;
use GateApi\HeaderSelector;
use GateApi\ObjectSerializer;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;

/**
 * EarnApi Class Doc Comment
 *
 * @category Class
 * @package  GateApi
 * @author   Gate
 * @link     https://www.gate.com
 */
class EarnApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation swapETH2
     *
     * ETH2 swap.
     *
     * @param  \GateApi\Model\Eth2Swap $eth2_swap eth2_swap (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function swapETH2($eth2_swap)
    {
        $this->swapETH2WithHttpInfo($eth2_swap);
    }

    /**
     * Operation swapETH2WithHttpInfo
     *
     * ETH2 swap.
     *
     * @param  \GateApi\Model\Eth2Swap $eth2_swap (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function swapETH2WithHttpInfo($eth2_swap)
    {
        $request = $this->swapETH2Request($eth2_swap);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        return [null, $statusCode, $response->getHeaders()];
    }

    /**
     * Operation swapETH2Async
     *
     * ETH2 swap.
     *
     * @param  \GateApi\Model\Eth2Swap $eth2_swap (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapETH2Async($eth2_swap)
    {
        return $this->swapETH2AsyncWithHttpInfo($eth2_swap)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swapETH2AsyncWithHttpInfo
     *
     * ETH2 swap.
     *
     * @param  \GateApi\Model\Eth2Swap $eth2_swap (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapETH2AsyncWithHttpInfo($eth2_swap)
    {
        $returnType = '';
        $request = $this->swapETH2Request($eth2_swap);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swapETH2'
     *
     * @param  \GateApi\Model\Eth2Swap $eth2_swap (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swapETH2Request($eth2_swap)
    {
        // verify the required parameter 'eth2_swap' is set
        if ($eth2_swap === null || (is_array($eth2_swap) && count($eth2_swap) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eth2_swap when calling swapETH2'
            );
        }

        $resourcePath = '/earn/staking/eth2/swap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($eth2_swap)) {
            $_tempBody = $eth2_swap;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rateListETH2
     *
     * ETH2 historical rate of return query.
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\Eth2RateList[]
     */
    public function rateListETH2()
    {
        list($response) = $this->rateListETH2WithHttpInfo();
        return $response;
    }

    /**
     * Operation rateListETH2WithHttpInfo
     *
     * ETH2 historical rate of return query.
     *
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\Eth2RateList[], HTTP status code, HTTP response headers (array of strings)
     */
    public function rateListETH2WithHttpInfo()
    {
        $request = $this->rateListETH2Request();

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\Eth2RateList[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation rateListETH2Async
     *
     * ETH2 historical rate of return query.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rateListETH2Async()
    {
        return $this->rateListETH2AsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rateListETH2AsyncWithHttpInfo
     *
     * ETH2 historical rate of return query.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rateListETH2AsyncWithHttpInfo()
    {
        $returnType = '\GateApi\Model\Eth2RateList[]';
        $request = $this->rateListETH2Request();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rateListETH2'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rateListETH2Request()
    {

        $resourcePath = '/earn/staking/eth2/rate_records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDualInvestmentPlans
     *
     * Dual Investment product list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $plan_id Financial project id. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\DualGetPlans[]
     */
    public function listDualInvestmentPlans($associative_array)
    {
        list($response) = $this->listDualInvestmentPlansWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listDualInvestmentPlansWithHttpInfo
     *
     * Dual Investment product list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $plan_id Financial project id. (optional)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\DualGetPlans[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listDualInvestmentPlansWithHttpInfo($associative_array)
    {
        $request = $this->listDualInvestmentPlansRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\DualGetPlans[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listDualInvestmentPlansAsync
     *
     * Dual Investment product list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $plan_id Financial project id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDualInvestmentPlansAsync($associative_array)
    {
        return $this->listDualInvestmentPlansAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDualInvestmentPlansAsyncWithHttpInfo
     *
     * Dual Investment product list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $plan_id Financial project id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDualInvestmentPlansAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\DualGetPlans[]';
        $request = $this->listDualInvestmentPlansRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDualInvestmentPlans'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $plan_id Financial project id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listDualInvestmentPlansRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $plan_id = array_key_exists('plan_id', $associative_array) ? $associative_array['plan_id'] : null;


        $resourcePath = '/earn/dual/investment_plan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($plan_id !== null) {
            if('form' === 'form' && is_array($plan_id)) {
                foreach($plan_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['plan_id'] = $plan_id;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDualOrders
     *
     * Dual Investment order list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start checkout time. (optional)
     * @param  int $to End settlement time. (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\DualGetOrders[]
     */
    public function listDualOrders($associative_array)
    {
        list($response) = $this->listDualOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listDualOrdersWithHttpInfo
     *
     * Dual Investment order list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start checkout time. (optional)
     * @param  int $to End settlement time. (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\DualGetOrders[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listDualOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listDualOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\DualGetOrders[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listDualOrdersAsync
     *
     * Dual Investment order list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start checkout time. (optional)
     * @param  int $to End settlement time. (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDualOrdersAsync($associative_array)
    {
        return $this->listDualOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDualOrdersAsyncWithHttpInfo
     *
     * Dual Investment order list.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start checkout time. (optional)
     * @param  int $to End settlement time. (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDualOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\DualGetOrders[]';
        $request = $this->listDualOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDualOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start checkout time. (optional)
     * @param  int $to End settlement time. (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listDualOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : 1;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling EarnApi.listDualOrders, must be bigger than or equal to 1.');
        }

        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EarnApi.listDualOrders, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EarnApi.listDualOrders, must be bigger than or equal to 1.');
        }


        $resourcePath = '/earn/dual/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeDualOrder
     *
     * Place Dual Investment order.
     *
     * @param  \GateApi\Model\PlaceDualInvestmentOrder $place_dual_investment_order place_dual_investment_order (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function placeDualOrder($place_dual_investment_order)
    {
        $this->placeDualOrderWithHttpInfo($place_dual_investment_order);
    }

    /**
     * Operation placeDualOrderWithHttpInfo
     *
     * Place Dual Investment order.
     *
     * @param  \GateApi\Model\PlaceDualInvestmentOrder $place_dual_investment_order (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeDualOrderWithHttpInfo($place_dual_investment_order)
    {
        $request = $this->placeDualOrderRequest($place_dual_investment_order);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        return [null, $statusCode, $response->getHeaders()];
    }

    /**
     * Operation placeDualOrderAsync
     *
     * Place Dual Investment order.
     *
     * @param  \GateApi\Model\PlaceDualInvestmentOrder $place_dual_investment_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeDualOrderAsync($place_dual_investment_order)
    {
        return $this->placeDualOrderAsyncWithHttpInfo($place_dual_investment_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeDualOrderAsyncWithHttpInfo
     *
     * Place Dual Investment order.
     *
     * @param  \GateApi\Model\PlaceDualInvestmentOrder $place_dual_investment_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeDualOrderAsyncWithHttpInfo($place_dual_investment_order)
    {
        $returnType = '';
        $request = $this->placeDualOrderRequest($place_dual_investment_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeDualOrder'
     *
     * @param  \GateApi\Model\PlaceDualInvestmentOrder $place_dual_investment_order (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeDualOrderRequest($place_dual_investment_order)
    {
        // verify the required parameter 'place_dual_investment_order' is set
        if ($place_dual_investment_order === null || (is_array($place_dual_investment_order) && count($place_dual_investment_order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $place_dual_investment_order when calling placeDualOrder'
            );
        }

        $resourcePath = '/earn/dual/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($place_dual_investment_order)) {
            $_tempBody = $place_dual_investment_order;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStructuredProducts
     *
     * Structured Product List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Status (Default empty to query all)  &#x60;in_process&#x60;-In progress &#x60;will_begin&#x60;-Not started &#x60;wait_settlement&#x60;-Pending settlement &#x60;done&#x60;-Completed (required)
     * @param  string $type Product Type (Default empty to query all)  &#x60;SharkFin2.0&#x60;-Shark Fin &#x60;BullishSharkFin&#x60;-Bullish Treasure &#x60;BearishSharkFin&#x60;-Bearish Treasure &#x60;DoubleNoTouch&#x60;-Volatility Treasure &#x60;RangeAccrual&#x60;-Range Smart Yield &#x60;SnowBall&#x60;-Snowball (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\StructuredGetProjectList[]
     */
    public function listStructuredProducts($associative_array)
    {
        list($response) = $this->listStructuredProductsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listStructuredProductsWithHttpInfo
     *
     * Structured Product List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Status (Default empty to query all)  &#x60;in_process&#x60;-In progress &#x60;will_begin&#x60;-Not started &#x60;wait_settlement&#x60;-Pending settlement &#x60;done&#x60;-Completed (required)
     * @param  string $type Product Type (Default empty to query all)  &#x60;SharkFin2.0&#x60;-Shark Fin &#x60;BullishSharkFin&#x60;-Bullish Treasure &#x60;BearishSharkFin&#x60;-Bearish Treasure &#x60;DoubleNoTouch&#x60;-Volatility Treasure &#x60;RangeAccrual&#x60;-Range Smart Yield &#x60;SnowBall&#x60;-Snowball (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\StructuredGetProjectList[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listStructuredProductsWithHttpInfo($associative_array)
    {
        $request = $this->listStructuredProductsRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\StructuredGetProjectList[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listStructuredProductsAsync
     *
     * Structured Product List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Status (Default empty to query all)  &#x60;in_process&#x60;-In progress &#x60;will_begin&#x60;-Not started &#x60;wait_settlement&#x60;-Pending settlement &#x60;done&#x60;-Completed (required)
     * @param  string $type Product Type (Default empty to query all)  &#x60;SharkFin2.0&#x60;-Shark Fin &#x60;BullishSharkFin&#x60;-Bullish Treasure &#x60;BearishSharkFin&#x60;-Bearish Treasure &#x60;DoubleNoTouch&#x60;-Volatility Treasure &#x60;RangeAccrual&#x60;-Range Smart Yield &#x60;SnowBall&#x60;-Snowball (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStructuredProductsAsync($associative_array)
    {
        return $this->listStructuredProductsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStructuredProductsAsyncWithHttpInfo
     *
     * Structured Product List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Status (Default empty to query all)  &#x60;in_process&#x60;-In progress &#x60;will_begin&#x60;-Not started &#x60;wait_settlement&#x60;-Pending settlement &#x60;done&#x60;-Completed (required)
     * @param  string $type Product Type (Default empty to query all)  &#x60;SharkFin2.0&#x60;-Shark Fin &#x60;BullishSharkFin&#x60;-Bullish Treasure &#x60;BearishSharkFin&#x60;-Bearish Treasure &#x60;DoubleNoTouch&#x60;-Volatility Treasure &#x60;RangeAccrual&#x60;-Range Smart Yield &#x60;SnowBall&#x60;-Snowball (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStructuredProductsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\StructuredGetProjectList[]';
        $request = $this->listStructuredProductsRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStructuredProducts'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $status Status (Default empty to query all)  &#x60;in_process&#x60;-In progress &#x60;will_begin&#x60;-Not started &#x60;wait_settlement&#x60;-Pending settlement &#x60;done&#x60;-Completed (required)
     * @param  string $type Product Type (Default empty to query all)  &#x60;SharkFin2.0&#x60;-Shark Fin &#x60;BullishSharkFin&#x60;-Bullish Treasure &#x60;BearishSharkFin&#x60;-Bearish Treasure &#x60;DoubleNoTouch&#x60;-Volatility Treasure &#x60;RangeAccrual&#x60;-Range Smart Yield &#x60;SnowBall&#x60;-Snowball (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listStructuredProductsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $status = array_key_exists('status', $associative_array) ? $associative_array['status'] : null;
        $type = array_key_exists('type', $associative_array) ? $associative_array['type'] : null;
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : 1;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;

        // verify the required parameter 'status' is set
        if ($status === null || (is_array($status) && count($status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status when calling listStructuredProducts'
            );
        }
        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling EarnApi.listStructuredProducts, must be bigger than or equal to 1.');
        }

        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EarnApi.listStructuredProducts, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EarnApi.listStructuredProducts, must be bigger than or equal to 1.');
        }


        $resourcePath = '/earn/structured/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStructuredOrders
     *
     * Structured Product Order List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\StructuredOrderList[]
     */
    public function listStructuredOrders($associative_array)
    {
        list($response) = $this->listStructuredOrdersWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation listStructuredOrdersWithHttpInfo
     *
     * Structured Product Order List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\StructuredOrderList[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listStructuredOrdersWithHttpInfo($associative_array)
    {
        $request = $this->listStructuredOrdersRequest($associative_array);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\StructuredOrderList[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation listStructuredOrdersAsync
     *
     * Structured Product Order List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStructuredOrdersAsync($associative_array)
    {
        return $this->listStructuredOrdersAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStructuredOrdersAsyncWithHttpInfo
     *
     * Structured Product Order List.
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStructuredOrdersAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\GateApi\Model\StructuredOrderList[]';
        $request = $this->listStructuredOrdersRequest($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStructuredOrders'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit) (optional)
     * @param  int $to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp (optional)
     * @param  int $page Page number. (optional, default to 1)
     * @param  int $limit Maximum number of records to be returned in a single list. (optional, default to 100)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listStructuredOrdersRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $from = array_key_exists('from', $associative_array) ? $associative_array['from'] : null;
        $to = array_key_exists('to', $associative_array) ? $associative_array['to'] : null;
        $page = array_key_exists('page', $associative_array) ? $associative_array['page'] : 1;
        $limit = array_key_exists('limit', $associative_array) ? $associative_array['limit'] : 100;

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling EarnApi.listStructuredOrders, must be bigger than or equal to 1.');
        }

        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EarnApi.listStructuredOrders, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EarnApi.listStructuredOrders, must be bigger than or equal to 1.');
        }


        $resourcePath = '/earn/structured/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }

        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }

        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeStructuredOrder
     *
     * Place Structured Product Order.
     *
     * @param  \GateApi\Model\StructuredBuy $structured_buy structured_buy (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function placeStructuredOrder($structured_buy)
    {
        $this->placeStructuredOrderWithHttpInfo($structured_buy);
    }

    /**
     * Operation placeStructuredOrderWithHttpInfo
     *
     * Place Structured Product Order.
     *
     * @param  \GateApi\Model\StructuredBuy $structured_buy (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeStructuredOrderWithHttpInfo($structured_buy)
    {
        $request = $this->placeStructuredOrderRequest($structured_buy);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        return [null, $statusCode, $response->getHeaders()];
    }

    /**
     * Operation placeStructuredOrderAsync
     *
     * Place Structured Product Order.
     *
     * @param  \GateApi\Model\StructuredBuy $structured_buy (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeStructuredOrderAsync($structured_buy)
    {
        return $this->placeStructuredOrderAsyncWithHttpInfo($structured_buy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeStructuredOrderAsyncWithHttpInfo
     *
     * Place Structured Product Order.
     *
     * @param  \GateApi\Model\StructuredBuy $structured_buy (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeStructuredOrderAsyncWithHttpInfo($structured_buy)
    {
        $returnType = '';
        $request = $this->placeStructuredOrderRequest($structured_buy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeStructuredOrder'
     *
     * @param  \GateApi\Model\StructuredBuy $structured_buy (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeStructuredOrderRequest($structured_buy)
    {
        // verify the required parameter 'structured_buy' is set
        if ($structured_buy === null || (is_array($structured_buy) && count($structured_buy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $structured_buy when calling placeStructuredOrder'
            );
        }

        $resourcePath = '/earn/structured/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($structured_buy)) {
            $_tempBody = $structured_buy;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findCoin
     *
     * Staking Coins.
     *
     * @param  \GateApi\Model\FindCoin $find_coin find_coin (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function findCoin($find_coin)
    {
        list($response) = $this->findCoinWithHttpInfo($find_coin);
        return $response;
    }

    /**
     * Operation findCoinWithHttpInfo
     *
     * Staking Coins.
     *
     * @param  \GateApi\Model\FindCoin $find_coin (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function findCoinWithHttpInfo($find_coin)
    {
        $request = $this->findCoinRequest($find_coin);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = 'string[]';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation findCoinAsync
     *
     * Staking Coins.
     *
     * @param  \GateApi\Model\FindCoin $find_coin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findCoinAsync($find_coin)
    {
        return $this->findCoinAsyncWithHttpInfo($find_coin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findCoinAsyncWithHttpInfo
     *
     * Staking Coins.
     *
     * @param  \GateApi\Model\FindCoin $find_coin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findCoinAsyncWithHttpInfo($find_coin)
    {
        $returnType = 'string[]';
        $request = $this->findCoinRequest($find_coin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findCoin'
     *
     * @param  \GateApi\Model\FindCoin $find_coin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findCoinRequest($find_coin)
    {
        // verify the required parameter 'find_coin' is set
        if ($find_coin === null || (is_array($find_coin) && count($find_coin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $find_coin when calling findCoin'
            );
        }

        $resourcePath = '/earn/staking/coins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($find_coin)) {
            $_tempBody = $find_coin;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('GET', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swapStakingCoin
     *
     * On-chain Token Swap for Earned Coins.
     *
     * @param  \GateApi\Model\SwapCoin $swap_coin swap_coin (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \GateApi\Model\SwapCoinStruct
     */
    public function swapStakingCoin($swap_coin)
    {
        list($response) = $this->swapStakingCoinWithHttpInfo($swap_coin);
        return $response;
    }

    /**
     * Operation swapStakingCoinWithHttpInfo
     *
     * On-chain Token Swap for Earned Coins.
     *
     * @param  \GateApi\Model\SwapCoin $swap_coin (required)
     *
     * @throws \GateApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \GateApi\Model\SwapCoinStruct, HTTP status code, HTTP response headers (array of strings)
     */
    public function swapStakingCoinWithHttpInfo($swap_coin)
    {
        $request = $this->swapStakingCoinRequest($swap_coin);

        $options = $this->createHttpClientOption();
        try {
            $response = $this->client->send($request, $options);
        } catch (RequestException $e) {
            $responseBody = $e->getResponse() ? (string) $e->getResponse()->getBody() : null;
            if ($responseBody != null) {
                $gateError = json_decode($responseBody, true);
                if ($gateError !== null && isset($gateError['label'])) {
                    throw new GateApiException(
                        $gateError,
                        $e->getCode(),
                        $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                        $responseBody
                    );
                }
            }
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                $e->getCode(),
                $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                $responseBody
            );
        }

        $returnType = '\GateApi\Model\SwapCoinStruct';
        $responseBody = $response->getBody();
        if ($returnType === '\SplFileObject') {
            $content = $responseBody; //stream goes to serializer
        } else {
            $content = (string) $responseBody;
        }

        return [
            ObjectSerializer::deserialize($content, $returnType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    /**
     * Operation swapStakingCoinAsync
     *
     * On-chain Token Swap for Earned Coins.
     *
     * @param  \GateApi\Model\SwapCoin $swap_coin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapStakingCoinAsync($swap_coin)
    {
        return $this->swapStakingCoinAsyncWithHttpInfo($swap_coin)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swapStakingCoinAsyncWithHttpInfo
     *
     * On-chain Token Swap for Earned Coins.
     *
     * @param  \GateApi\Model\SwapCoin $swap_coin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapStakingCoinAsyncWithHttpInfo($swap_coin)
    {
        $returnType = '\GateApi\Model\SwapCoinStruct';
        $request = $this->swapStakingCoinRequest($swap_coin);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swapStakingCoin'
     *
     * @param  \GateApi\Model\SwapCoin $swap_coin (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swapStakingCoinRequest($swap_coin)
    {
        // verify the required parameter 'swap_coin' is set
        if ($swap_coin === null || (is_array($swap_coin) && count($swap_coin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $swap_coin when calling swapStakingCoin'
            );
        }

        $resourcePath = '/earn/staking/swap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // body params
        $_tempBody = null;
        if (isset($swap_coin)) {
            $_tempBody = $swap_coin;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Gate APIv4 authentication
        $signHeaders = $this->config->buildSignHeaders('POST', $resourcePath, $queryParams, $httpBody);
        $headers = array_merge($headers, $signHeaders);

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
